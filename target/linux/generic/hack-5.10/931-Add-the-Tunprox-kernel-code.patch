From 849d5b37096c060891e61d329c1f1b21f0903426 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ar=C4=B1n=C3=A7=20=C3=9CNAL?= <arinc.unal@arinc9.com>
Date: Tue, 28 May 2024 16:12:44 +0300
Subject: [PATCH 2/3] Add the Tunprox kernel code
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Arınç ÜNAL <arinc.unal@arinc9.com>
---
 net/Kconfig           |    1 +
 net/Makefile          |    1 +
 net/ldt/Kconfig       |    4 +
 net/ldt/Makefile      |   66 ++
 net/ldt/ldt_addr.h    |  255 ++++++
 net/ldt/ldt_debug.h   |  109 +++
 net/ldt/ldt_dev.c     |  943 +++++++++++++++++++
 net/ldt/ldt_dev.h     |  193 ++++
 net/ldt/ldt_event.c   |  316 +++++++
 net/ldt/ldt_event.h   |   95 ++
 net/ldt/ldt_ip.c      |  250 +++++
 net/ldt/ldt_ip.h      |   93 ++
 net/ldt/ldt_lock.c    |  137 +++
 net/ldt/ldt_lock.h    |   86 ++
 net/ldt/ldt_mod.c     |  139 +++
 net/ldt/ldt_mpdccp.c  | 2001 +++++++++++++++++++++++++++++++++++++++++
 net/ldt/ldt_mpdccp.h  |   79 ++
 net/ldt/ldt_netlink.c | 1309 +++++++++++++++++++++++++++
 net/ldt/ldt_netlink.h |   84 ++
 net/ldt/ldt_prot1.c   |  145 +++
 net/ldt/ldt_prot1.h   |  125 +++
 net/ldt/ldt_queue.c   |  303 +++++++
 net/ldt/ldt_queue.h   |  102 +++
 net/ldt/ldt_sysctl.c  |  207 +++++
 net/ldt/ldt_sysctl.h  |   90 ++
 net/ldt/ldt_tun.c     |  422 +++++++++
 net/ldt/ldt_tun.h     |  162 ++++
 net/ldt/ldt_tunaddr.c |  200 ++++
 net/ldt/ldt_tunaddr.h |  101 +++
 net/ldt/ldt_uapi.h    |  302 +++++++
 net/ldt/ldt_version.h |    2 +
 31 files changed, 8322 insertions(+)
 create mode 100644 net/ldt/Kconfig
 create mode 100644 net/ldt/Makefile
 create mode 100644 net/ldt/ldt_addr.h
 create mode 100644 net/ldt/ldt_debug.h
 create mode 100644 net/ldt/ldt_dev.c
 create mode 100644 net/ldt/ldt_dev.h
 create mode 100644 net/ldt/ldt_event.c
 create mode 100644 net/ldt/ldt_event.h
 create mode 100644 net/ldt/ldt_ip.c
 create mode 100644 net/ldt/ldt_ip.h
 create mode 100644 net/ldt/ldt_lock.c
 create mode 100644 net/ldt/ldt_lock.h
 create mode 100644 net/ldt/ldt_mod.c
 create mode 100644 net/ldt/ldt_mpdccp.c
 create mode 100644 net/ldt/ldt_mpdccp.h
 create mode 100644 net/ldt/ldt_netlink.c
 create mode 100644 net/ldt/ldt_netlink.h
 create mode 100644 net/ldt/ldt_prot1.c
 create mode 100644 net/ldt/ldt_prot1.h
 create mode 100644 net/ldt/ldt_queue.c
 create mode 100644 net/ldt/ldt_queue.h
 create mode 100644 net/ldt/ldt_sysctl.c
 create mode 100644 net/ldt/ldt_sysctl.h
 create mode 100644 net/ldt/ldt_tun.c
 create mode 100644 net/ldt/ldt_tun.h
 create mode 100644 net/ldt/ldt_tunaddr.c
 create mode 100644 net/ldt/ldt_tunaddr.h
 create mode 100644 net/ldt/ldt_uapi.h
 create mode 100644 net/ldt/ldt_version.h

diff --git a/net/Kconfig b/net/Kconfig
index a22c3fb885647..b43effc22a06d 100644
--- a/net/Kconfig
+++ b/net/Kconfig
@@ -67,6 +67,7 @@ source "net/xfrm/Kconfig"
 source "net/iucv/Kconfig"
 source "net/smc/Kconfig"
 source "net/xdp/Kconfig"
+source "net/ldt/Kconfig"
 
 config INET
 	bool "TCP/IP networking"
diff --git a/net/Makefile b/net/Makefile
index 45c03aa92ace7..7c303438ee5a7 100644
--- a/net/Makefile
+++ b/net/Makefile
@@ -87,3 +87,4 @@ obj-$(CONFIG_QRTR)		+= qrtr/
 obj-$(CONFIG_NET_NCSI)		+= ncsi/
 obj-$(CONFIG_XDP_SOCKETS)	+= xdp/
 obj-$(CONFIG_MPTCP)		+= mptcp/
+obj-$(CONFIG_LDT)		+= ldt/
diff --git a/net/ldt/Kconfig b/net/ldt/Kconfig
new file mode 100644
index 0000000000000..fd37612c3787e
--- /dev/null
+++ b/net/ldt/Kconfig
@@ -0,0 +1,4 @@
+config LDT
+        tristate "ldt"
+        help
+          LDT is a (mp-)dccp tunnel in kernel space.
diff --git a/net/ldt/Makefile b/net/ldt/Makefile
new file mode 100644
index 0000000000000..16194fe9afbec
--- /dev/null
+++ b/net/ldt/Makefile
@@ -0,0 +1,66 @@
+#
+# Copyright (C) 2015-2022 by Frank Reker, Deutsche Telekom AG
+#
+# LDT - Lightweight (MP-)DCCP Tunnel kernel module
+#
+# This is not Open Source software.
+# This work is made available to you under a source-available license, as
+# detailed below.
+#
+# Copyright 2022 Deutsche Telekom AG
+#
+# Permission is hereby granted, free of charge, subject to below Commons
+# Clause, to any person obtaining a copy of this software and associated
+# documentation files (the "Software"), to deal in the Software without
+# restriction, including without limitation the rights to use, copy, modify,
+# merge, publish, distribute, sublicense, and/or sell copies of the Software,
+# and to permit persons to whom the Software is furnished to do so, subject to
+# the following conditions:
+#
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+# DEALINGS IN THE SOFTWARE.
+#
+# “Commons Clause” License Condition v1.0
+#
+# The Software is provided to you by the Licensor under the License, as
+# defined below, subject to the following condition.
+#
+# Without limiting other conditions in the License, the grant of rights under
+# the License will not include, and the License does not grant to you, the
+# right to Sell the Software.
+#
+# For purposes of the foregoing, “Sell” means practicing any or all of the
+# rights granted to you under the License to provide to third parties, for a
+# fee or other consideration (including without limitation fees for hosting
+# or consulting/ support services related to the Software), a product or
+# service whose value derives, entirely or substantially, from the
+# functionality of the Software. Any license notice or attribution required
+# by the License must also include this Commons Clause License Condition
+# notice.
+#
+# Licensor: Deutsche Telekom AG
+#
+
+obj-$(CONFIG_LDT) += ldt.o
+
+ldt-objs := \
+	ldt_dev.o \
+	ldt_event.o \
+	ldt_ip.o \
+	ldt_mod.o \
+	ldt_mpdccp.o \
+	ldt_netlink.o \
+	ldt_prot1.o \
+	ldt_sysctl.o \
+	ldt_tunaddr.o \
+	ldt_tun.o \
+	ldt_queue.o \
+	ldt_lock.o
diff --git a/net/ldt/ldt_addr.h b/net/ldt/ldt_addr.h
new file mode 100644
index 0000000000000..7d92abadd9f50
--- /dev/null
+++ b/net/ldt/ldt_addr.h
@@ -0,0 +1,255 @@
+/*
+ * Copyright (C) 2015-2022 by Frank Reker, Deutsche Telekom AG
+ *
+ * LDT - Lightweight (MP-)DCCP Tunnel kernel module
+ *
+ * This is not Open Source software.
+ * This work is made available to you under a source-available license, as
+ * detailed below.
+ *
+ * Copyright 2022 Deutsche Telekom AG
+ *
+ * Permission is hereby granted, free of charge, subject to below Commons
+ * Clause, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * “Commons Clause” License Condition v1.0
+ *
+ * The Software is provided to you by the Licensor under the License, as
+ * defined below, subject to the following condition.
+ *
+ * Without limiting other conditions in the License, the grant of rights under
+ * the License will not include, and the License does not grant to you, the
+ * right to Sell the Software.
+ *
+ * For purposes of the foregoing, “Sell” means practicing any or all of the
+ * rights granted to you under the License to provide to third parties, for a
+ * fee or other consideration (including without limitation fees for hosting
+ * or consulting/ support services related to the Software), a product or
+ * service whose value derives, entirely or substantially, from the
+ * functionality of the Software. Any license notice or attribution required
+ * by the License must also include this Commons Clause License Condition
+ * notice.
+ *
+ * Licensor: Deutsche Telekom AG
+ */
+
+#ifndef _R__KERNEL_LDT_ADDR_INT_H
+#define _R__KERNEL_LDT_ADDR_INT_H
+
+#include <linux/socket.h>
+#include <linux/in6.h>
+#include <linux/in.h>
+#include <linux/string.h>
+
+
+typedef union {
+	struct sockaddr		ad;
+	struct sockaddr_in	v4;
+	struct sockaddr_in6	v6;
+} tp_addr_t;
+
+
+#define TP_ADDR_FAM(a)		((a).ad.sa_family)
+#define TP_ADDRP_FAM(a)		(TP_ADDR_FAM(*a))
+#define TP_ADDR_ISIPV6(a)	(TP_ADDR_FAM(a) == AF_INET6)
+#define TP_ADDRP_ISIPV6(a)	(TP_ADDR_ISIPV6(*a))
+#define TP_ADDR_ISIPV4(a)	(TP_ADDR_FAM(a) == AF_INET)
+#define TP_ADDRP_ISIPV4(a)	(TP_ADDR_ISIPV4(*a))
+#define TP_ADDR_SIZE(a)		(TP_ADDR_ISIPV6(a) ? sizeof (struct sockaddr_in6) : sizeof (struct sockaddr_in))
+#define TP_ADDRP_SIZE(a)	(TP_ADDR_SIZE(*a))
+
+static inline void tp_addr_setipv4 (
+	tp_addr_t	*ad,
+	u32			ad4,
+	u16			port)
+{
+	if (!ad) return;
+	ad->v4 = (struct sockaddr_in) {
+		.sin_family = AF_INET,
+		.sin_addr.s_addr = ad4,
+		.sin_port = htons (port),
+	};
+}
+
+static inline void tp_addr_setipv6 (
+	tp_addr_t	*ad,
+	u8				ad6[16],
+	u16			port)
+{
+	if (!ad) return;
+	ad->v6 = (struct sockaddr_in6) {
+		.sin6_family = AF_INET6,
+		.sin6_port = htons (port),
+	};
+	memcpy (ad->v6.sin6_addr.s6_addr, ad6, 16);
+}
+
+static inline void tp_addr_setipv4only (
+	tp_addr_t	*ad,
+	u32			ad4)
+{
+	if (!ad) return;
+	if (TP_ADDRP_FAM(ad) != AF_INET) return;
+	ad->v4.sin_addr.s_addr = ad4;
+}
+
+static inline void tp_addr_setipv6only (
+	tp_addr_t	*ad,
+	u8				ad6[16])
+{
+	if (!ad) return;
+	if (TP_ADDRP_FAM(ad) != AF_INET6) return;
+	memcpy (ad->v6.sin6_addr.s6_addr, ad6, 16);
+}
+
+static inline void tp_addr_cpiponly (
+	tp_addr_t	*ad,
+	tp_addr_t	*ad2)
+{
+	if (!ad) return;
+	if (TP_ADDRP_FAM(ad) != TP_ADDRP_FAM(ad2)) return;
+	if (TP_ADDRP_ISIPV6(ad)) {
+		tp_addr_setipv6only (ad, ad2->v6.sin6_addr.s6_addr);
+	} else if (TP_ADDRP_ISIPV4(ad)) {
+		tp_addr_setipv4only (ad, ad2->v4.sin_addr.s_addr);
+	}
+}
+
+static inline void tp_addr_setport (
+	tp_addr_t	*ad,
+	u16			port)
+{
+	if (!ad) return;
+	if (TP_ADDRP_ISIPV6(ad)) {
+		ad->v6.sin6_port = htons (port);
+	} else {
+		ad->v4.sin_port = htons (port);
+	}
+}
+
+static inline u16 tp_addr_getport (tp_addr_t *ad)
+{
+	if (!ad) return 0;
+	if (TP_ADDRP_ISIPV6(ad)) {
+		return htons (ad->v6.sin6_port);
+	} else {
+		return htons (ad->v4.sin_port);
+	}
+}
+#define tp_addr_getuport(ad)		((unsigned)tp_addr_getport(ad))
+
+
+static inline int tp_addr_isany (
+	tp_addr_t	*ad)
+{
+	if (!ad) return 1;
+	if (TP_ADDRP_ISIPV6(ad)) {
+		int	i;
+#if defined __UAPI_DEF_IN6_ADDR_ALT
+		for (i=0; i<4; i++)
+         if (ad->v6.sin6_addr.s6_addr32[i]) return 0;
+#else
+		for (i=0; i<16; i++)
+         if (ad->v6.sin6_addr.s6_addr[i]) return 0;
+#endif
+		return 1;
+	} else {
+		return !(ad->v4.sin_addr.s_addr);
+	}
+}
+
+static inline int tp_addr_sprt_ip (
+	char			*buf,
+	size_t		size,
+	tp_addr_t	*ad)
+{
+	if (!buf || !ad) return 0;
+	/* %pIS does not exist on 3.10, so do it the hard way */
+	if (TP_ADDRP_ISIPV6(ad)) {
+		return snprintf (buf, size, "%pI6", &ad->v6.sin6_addr);
+	} else {
+		return snprintf (buf, size, "%pI4", &ad->v4.sin_addr);
+	}
+}
+
+static inline int tp_addr_sprt (
+	char			*buf,
+	size_t		size,
+	tp_addr_t	*ad)
+{
+	if (!buf || !ad) return 0;
+	if (TP_ADDRP_ISIPV6(ad)) {
+		return snprintf (buf, size, "[%pI6]:%d", &ad->v6.sin6_addr, ad->v6.sin6_port);
+	} else {
+		return snprintf (buf, size, "%pI4:%d", &ad->v4.sin_addr, ad->v4.sin_port);
+	}
+}
+
+
+static inline int tp_addr_eq (
+	tp_addr_t	*ad1,
+	tp_addr_t	*ad2)
+{
+	if (!ad1 || !ad2) return 0;
+	if (TP_ADDRP_FAM(ad1) != TP_ADDRP_FAM(ad2)) return 0;
+	if (TP_ADDRP_ISIPV6(ad1)) {
+		if (ad1->v6.sin6_port != ad2->v6.sin6_port) return 0;
+		if (memcmp (ad1->v6.sin6_addr.s6_addr, ad2->v6.sin6_addr.s6_addr, 16)) return 0;
+		return 1;
+	} else {
+		if (ad1->v4.sin_port != ad2->v4.sin_port) return 0;
+		if (ad1->v4.sin_addr.s_addr != ad2->v4.sin_addr.s_addr) return 0;
+		return 1;
+	}
+}
+
+static inline void tp_addr_cp (
+	tp_addr_t	*ad1,
+	tp_addr_t	*ad2)
+{
+	if (!ad1 || !ad2) return;
+	if (TP_ADDRP_ISIPV6(ad2)) {
+		tp_addr_setipv6 (ad1, ad2->v6.sin6_addr.s6_addr, htons(ad2->v6.sin6_port));
+	} else {
+		tp_addr_setipv4 (ad1, ad2->v4.sin_addr.s_addr, htons(ad2->v4.sin_port));
+	}
+}
+
+
+
+
+
+
+
+#endif	/* _R__KERNEL_LDT_ADDR_INT_H */
+
+
+/*
+ * Overrides for XEmacs and vim so that we get a uniform tabbing style.
+ * XEmacs/vim will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 3
+ * c-basic-offset: 3
+ * tab-width: 3
+ * End:
+ * vim:tw=0:ts=3:wm=0:
+ */
diff --git a/net/ldt/ldt_debug.h b/net/ldt/ldt_debug.h
new file mode 100644
index 0000000000000..de99f70ac2986
--- /dev/null
+++ b/net/ldt/ldt_debug.h
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2015-2022 by Frank Reker, Deutsche Telekom AG
+ *
+ * LDT - Lightweight (MP-)DCCP Tunnel kernel module
+ *
+ * This is not Open Source software.
+ * This work is made available to you under a source-available license, as
+ * detailed below.
+ *
+ * Copyright 2022 Deutsche Telekom AG
+ *
+ * Permission is hereby granted, free of charge, subject to below Commons
+ * Clause, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * “Commons Clause” License Condition v1.0
+ *
+ * The Software is provided to you by the Licensor under the License, as
+ * defined below, subject to the following condition.
+ *
+ * Without limiting other conditions in the License, the grant of rights under
+ * the License will not include, and the License does not grant to you, the
+ * right to Sell the Software.
+ *
+ * For purposes of the foregoing, “Sell” means practicing any or all of the
+ * rights granted to you under the License to provide to third parties, for a
+ * fee or other consideration (including without limitation fees for hosting
+ * or consulting/ support services related to the Software), a product or
+ * service whose value derives, entirely or substantially, from the
+ * functionality of the Software. Any license notice or attribution required
+ * by the License must also include this Commons Clause License Condition
+ * notice.
+ *
+ * Licensor: Deutsche Telekom AG
+ */
+
+#ifndef _R__KERNEL_LDT_DEBUG_H
+#define _R__KERNEL_LDT_DEBUG_H
+
+#include "ldt_sysctl.h"
+
+#define TP_PRTK_RATE(a)	(\
+			((a) || !(tp_cfg_logflags & TP_CFG_LOG_F_RATELIMIT) || \
+			 printk_ratelimit()))
+
+#define TP_FILE	( { const char *s = strrchr (__FILE__, '/'); s ? s+1 : __FILE__; } )
+#define TP_EOL(fmt)	( ((fmt) && *(fmt) && (fmt)[strlen(fmt)-1] == '\n') ? "" : "\n" )
+#define TP_PRTK(enable,norate,hdr,fmt,a...) \
+				do { \
+					if (enable && TP_PRTK_RATE(norate)) { \
+						if (tp_cfg_logflags & TP_CFG_LOG_F_PRTFILE) \
+							printk (hdr "%s(%s:%d):%s(): " fmt "%s", KBUILD_MODNAME, \
+										TP_FILE, __LINE__,__func__, ##a, TP_EOL(fmt)); \
+						else \
+							printk (hdr "%s:%s(): " fmt "%s", KBUILD_MODNAME, \
+										__func__, ##a, TP_EOL(fmt)); \
+					} \
+				} while(0)
+#define TP_PRTKL(mlevel,norate,hdr,fmt,a...) \
+				TP_PRTK((tp_cfg_loglevel >= (mlevel)), norate, hdr, fmt, ##a)
+
+#define tp_debug(fmt,a...)  TP_PRTKL(7, 0, KERN_DEBUG,   fmt, ##a)
+#define tp_debug2(fmt,a...) TP_PRTKL(8, 0, KERN_DEBUG,   fmt, ##a)
+#define tp_debug3(fmt,a...) TP_PRTKL(9, 0, KERN_DEBUG,   fmt, ##a)
+#define tp_info(fmt,a...)   TP_PRTKL(6, 0, KERN_INFO,    fmt, ##a)
+#define tp_note(fmt,a...)   TP_PRTKL(5, 1, KERN_NOTICE,  fmt, ##a)
+#define tp_warn(fmt,a...)   TP_PRTKL(4, 1, KERN_WARNING, fmt, ##a)
+#define tp_err(fmt,a...)    TP_PRTKL(3, 1, KERN_ERR,     fmt, ##a)
+#define tp_crit(fmt,a...)   TP_PRTKL(2, 1, KERN_CRIT,    fmt, ##a)
+#define tp_alert(fmt,a...)  TP_PRTKL(1, 1, KERN_ALERT,   fmt, ##a)
+#define tp_emerg(fmt,a...)  TP_PRTKL(0, 1, KERN_EMERG,   fmt, ##a)
+#define tp_prtk(fmt,a...)   TP_PRTK( 1, 1, "",           fmt, ##a)
+
+
+
+
+
+
+#endif	/* _R__KERNEL_LDT_DEBUG_H */
+
+
+/*
+ * Overrides for XEmacs and vim so that we get a uniform tabbing style.
+ * XEmacs/vim will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 3
+ * c-basic-offset: 3
+ * tab-width: 3
+ * End:
+ * vim:tw=0:ts=3:wm=0:
+ */
diff --git a/net/ldt/ldt_dev.c b/net/ldt/ldt_dev.c
new file mode 100644
index 0000000000000..bdb6311811424
--- /dev/null
+++ b/net/ldt/ldt_dev.c
@@ -0,0 +1,943 @@
+/*
+ * Copyright (C) 2015-2022 by Frank Reker, Deutsche Telekom AG
+ *
+ * LDT - Lightweight (MP-)DCCP Tunnel kernel module
+ *
+ * This is not Open Source software.
+ * This work is made available to you under a source-available license, as
+ * detailed below.
+ *
+ * Copyright 2022 Deutsche Telekom AG
+ *
+ * Permission is hereby granted, free of charge, subject to below Commons
+ * Clause, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * “Commons Clause” License Condition v1.0
+ *
+ * The Software is provided to you by the Licensor under the License, as
+ * defined below, subject to the following condition.
+ *
+ * Without limiting other conditions in the License, the grant of rights under
+ * the License will not include, and the License does not grant to you, the
+ * right to Sell the Software.
+ *
+ * For purposes of the foregoing, “Sell” means practicing any or all of the
+ * rights granted to you under the License to provide to third parties, for a
+ * fee or other consideration (including without limitation fees for hosting
+ * or consulting/ support services related to the Software), a product or
+ * service whose value derives, entirely or substantially, from the
+ * functionality of the Software. Any license notice or attribution required
+ * by the License must also include this Commons Clause License Condition
+ * notice.
+ *
+ * Licensor: Deutsche Telekom AG
+ */
+
+
+#include <linux/socket.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/netlink.h>
+#include <net/sock.h>
+#include <net/tcp_states.h>
+#include <net/genetlink.h>
+#include <linux/skbuff.h>
+#include <linux/notifier.h>
+#include <net/arp.h>
+#include <linux/if_arp.h>
+#include <linux/list.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/rtnetlink.h>
+#include <linux/spinlock.h>
+#include <linux/in.h>
+#include <linux/in6.h>
+#include <net/net_namespace.h>
+#include <linux/inetdevice.h>
+#include <net/if_inet6.h>
+#include <linux/version.h>
+
+
+#include "ldt_uapi.h"
+#include "ldt_debug.h"
+#include "ldt_dev.h"
+#include "ldt_tun.h"
+#include "ldt_event.h"
+#include "ldt_lock.h"
+
+
+static struct net_device_stats* tpdev_getstats (struct net_device*);
+static int tpdev_close (struct net_device*);
+static int tpdev_open (struct net_device*);
+static void tpdev_setup (struct net_device *);
+static int tpdev_setflags (struct ldt_dev *, int);
+static void tpdev_uninit (struct net_device*);
+static void ldt_rm_tun2 (struct ldt_dev*);
+static netdev_tx_t tpdev_xmit (struct sk_buff*, struct net_device*);
+static int tpdev_change_mtu (struct net_device*, int);
+static ssize_t get_devinfo (struct ldt_dev *, char*, size_t);
+static int tpdev_ndevdown (struct ldt_dev*);
+static int tpdev_ndevup (struct ldt_dev*);
+static int tp_ev_up (struct net_device*);
+static int tp_ev_down (struct net_device*);
+static int tp_ev_ndev (struct notifier_block *, unsigned long, void*);
+static void ldt_remove_all (void);
+
+
+
+#define DEV_LOCK(tdev)		do { if (tdev) tp_lock (&(tdev)->lock); } while (0)
+#define DEV_UNLOCK(tdev)	do { if (tdev) tp_unlock (&(tdev)->lock); } while (0)
+#define DEV_OK(tdev) (ISLDTDEV(tdev) && ISACTIVETPDEV(tdev))
+#define DEV_LOCK_CHK(tdev)  ( { int _ret; DEV_LOCK(tdev); _ret=DEV_OK(tdev); if (!_ret) DEV_UNLOCK(tdev); _ret; } )
+#define SETACTIVE(tdev,on) do { smp_store_release (&(tdev->active), on); } while (0)
+
+
+static struct notifier_block tpdev_watch_netdev_notifier = {
+   .notifier_call = tp_ev_ndev,
+};
+
+static struct device_type	tp_devtype = {
+	.name = "ldt",
+};
+
+static HLIST_HEAD(ldt_dev_list);
+static struct tp_lock	ldt_dev_list_lock;
+#define LDLLOCK	do { tp_lock (&ldt_dev_list_lock); } while (0)
+#define LDLULOCK	do { tp_unlock (&ldt_dev_list_lock); } while (0)
+
+int
+ldt_dev_global_init (void)
+{
+	int   ret;
+
+	tp_lock_init (&ldt_dev_list_lock);
+	ret = register_netdevice_notifier (&tpdev_watch_netdev_notifier);
+	if (ret < 0) {
+		tp_err ("error registering netdev notifier: %d", ret);
+		return ret;
+	}
+	return 0;
+}
+
+void
+ldt_dev_global_destroy (void)
+{
+	unregister_netdevice_notifier (&tpdev_watch_netdev_notifier);
+	ldt_remove_all ();
+	tp_lock_destroy (&ldt_dev_list_lock);
+}
+
+int
+ldt_create_dev (net, name, out_name, flags)
+	struct net	*net;
+	const char	*name;
+	const char	**out_name;
+	int			flags;
+{
+	struct net_device		*ndev;
+	struct ldt_dev	*tdev;
+	int						ret;
+#ifdef NET_NAME_ENUM
+	int						assigntype = NET_NAME_USER;
+#endif
+
+	if (!name || !*name) {
+		name="ldt%d";
+#ifdef NET_NAME_ENUM
+		assigntype = NET_NAME_ENUM;
+#endif
+	} else if (strlen (name) > IFNAMSIZ-1) {
+		tp_err ("name >>%s<< too long (max=%d)\n", name, IFNAMSIZ-1);
+		return -EINVAL;
+	}
+	tp_debug ("create device %s\n", name);
+#ifdef NET_NAME_ENUM
+	ndev = alloc_netdev_mqs (	sizeof (struct ldt_dev), name, assigntype,
+										tpdev_setup, 1, 1);
+#else
+	ndev = alloc_netdev_mqs (	sizeof (struct ldt_dev), name,
+										tpdev_setup, 1, 1);
+#endif
+	if (!ndev) return -ENOMEM;
+#ifdef CONFIG_NET_NS
+	dev_net_set(ndev, net);
+#endif
+
+	tdev = (struct ldt_dev*) netdev_priv (ndev);
+	ret = tpdev_setflags (tdev, flags);
+	if (ret < 0) {
+		free_netdev(ndev);
+		return ret;
+	}
+	/* now register device */
+	ret = register_netdev (ndev);
+	if (ret < 0) {
+		tp_err ("register ldt device %s failed\n", ndev->name);
+		free_netdev (ndev);
+		return ret;
+	}
+	LDLLOCK;
+	hlist_add_head (&tdev->list, &ldt_dev_list);
+	LDLULOCK;
+
+	if (out_name) *out_name = ndev->name;
+	return 0;
+}
+
+static
+int
+tpdev_close (
+	struct net_device	*ndev)
+{
+	netif_stop_queue (ndev);
+	return 0;
+}
+
+static
+int
+tpdev_open (
+	struct net_device	*ndev)
+{
+	netif_start_queue (ndev);
+	return 0;
+}
+
+static
+struct net_device_stats *
+tpdev_getstats (
+	struct net_device	*ndev)
+{
+	return &ndev->stats;
+}
+
+
+static const struct net_device_ops	tp_devops = {
+	.ndo_open				= tpdev_open,
+	.ndo_stop				= tpdev_close,
+	.ndo_start_xmit		= tpdev_xmit,
+	.ndo_set_mac_address	= eth_mac_addr,
+	.ndo_change_mtu		= tpdev_change_mtu,
+	.ndo_uninit				= tpdev_uninit,
+	.ndo_get_stats			= tpdev_getstats,
+};
+
+static
+void
+tpdev_setup (
+	struct net_device	*ndev)
+{
+	struct ldt_dev	*tdev;
+	struct timespec64 ts;
+
+	/* lock must be held by caller */
+	if (!ndev) return;
+	ndev->netdev_ops = &tp_devops;
+	tdev = (struct ldt_dev*) netdev_priv (ndev);
+	*tdev = (struct ldt_dev) {
+		.ndev = ndev,
+	};
+	tp_lock_init (&tdev->lock);
+	ndev->mtu = 1350;
+	ndev->type = ARPHRD_PPP;
+	ndev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;
+	ndev->tx_queue_len = 10000;
+	//tdev->ctime = tdev->mtime = get_seconds();
+	ktime_get_raw_ts64(&ts);
+	tdev->ctime = tdev->mtime = ts.tv_sec;
+	SET_NETDEV_DEVTYPE(ndev, &tp_devtype);
+	tdev->MAGIC = LDT_MAGIC;
+	return;
+}
+
+static
+int
+tpdev_setflags (tdev, flags)
+	struct ldt_dev	*tdev;
+	int						flags;
+{
+	if (!tdev) return -EINVAL;
+
+	if (flags & LDT_CREATE_DEV_F_CLIENT)
+		tdev->client = 1;
+	else if (flags & LDT_CREATE_DEV_F_SERVER)
+		tdev->server = 1;
+	return 0;
+}
+
+
+void
+ldt_free_dev (tdev)
+	struct ldt_dev	*tdev;
+{
+	if (!DEV_OK(tdev)) return;
+	tpdev_close (tdev->ndev);
+	SETACTIVE(tdev,0);
+	tp_info ("remove dev %s\n", tdev->ndev->name);
+	ldt_event_crsend (LDT_EVTYPE_IFDOWN, tdev, 0);
+	dev_put (tdev->ndev);
+	LDLLOCK;
+	hlist_del (&tdev->list);
+	LDLULOCK;
+	unregister_netdev (tdev->ndev);
+	free_netdev (tdev->ndev);
+	return;
+}
+
+static
+void
+ldt_remove_all (void)
+{
+	struct ldt_dev		*tdev;
+	struct hlist_node	*tmp;
+
+	hlist_for_each_entry_safe (tdev, tmp, &ldt_dev_list, list) {
+		ldt_free_dev (tdev);
+	}
+}
+
+
+static
+void
+tpdev_uninit (ndev)
+	struct net_device		*ndev;
+{
+	struct ldt_dev	*tdev;
+
+	tdev = LDTDEV (ndev);
+	if (!tdev) return;
+	tp_debug ("uninit dev %s\n", tdev->ndev->name);
+	/* poison struct */
+	tdev->MAGIC = 0;
+
+	/* remove all tunnel */
+	ldt_rm_tun2 (tdev);
+	tp_lock_destroy (&tdev->lock);
+	return;
+}
+
+
+
+/*      Called when a packet needs to be transmitted.
+ *      Must return NETDEV_TX_OK , NETDEV_TX_BUSY.
+ *        (can also return NETDEV_TX_LOCKED iff NETIF_F_LLTX)
+ */
+static
+netdev_tx_t
+tpdev_xmit (skb, ndev)
+	struct sk_buff		*skb;
+	struct net_device	*ndev;
+{
+	struct ldt_dev	*tdev;
+	netdev_tx_t				ret;
+
+	if (!ndev || !skb) return 0;
+	tdev = LDTDEV (ndev);
+	if (!tdev) {
+		kfree_skb (skb);
+		return NETDEV_TX_OK;
+	}
+	if (!ISACTIVE(tdev)) {
+		return NETDEV_TX_BUSY;
+	}
+	ret = ldt_tun_xmit (&tdev->tun, skb);
+	return ret;
+}
+
+
+/*      Called when a user wants to change the Maximum Transfer Unit
+ *      of a device. If not defined, any request to change MTU will
+ *      will return an error.
+ */
+static
+int
+tpdev_change_mtu (ndev, new_mtu)
+	struct net_device	*ndev;
+	int					new_mtu;
+{
+	struct ldt_dev	*tdev;
+	int						ret = -ERANGE;
+	struct timespec64 ts;
+
+	if (!ndev) return -EINVAL;
+	tdev = LDTDEV (ndev);
+	if (!DEV_LOCK_CHK(tdev)) return 0;
+	if (new_mtu < 1280) goto out;
+	if (new_mtu > 65535) goto out;
+	ndev->mtu = new_mtu;
+	ret = 0;
+	//tdev->mtime = get_seconds();
+	ktime_get_raw_ts64(&ts);
+	tdev->mtime = ts.tv_sec;
+out:
+	DEV_UNLOCK(tdev);
+	return 0;
+}
+
+
+int
+ldt_get_devlist (net, devlist, dlen)
+	struct net	*net;
+	char			**devlist;
+	u32			*dlen;
+{
+	struct net_device		*pn;
+	int						len, num;
+	char						*s;
+
+	if (!net || !devlist || !dlen) return -EINVAL;
+	len=num=0;
+	read_lock (&dev_base_lock);
+	for_each_netdev (net, pn) {
+		if (!TPDEV_ISLDT(pn)) continue;
+		num++;
+	}
+	*devlist = kmalloc (num*(IFNAMSIZ+1)+1, GFP_KERNEL);
+	if (!*devlist) {
+		read_unlock (&dev_base_lock);
+		return -ENOMEM;
+	}
+	s=*devlist;
+	*s = 0;
+	for_each_netdev (net, pn) {
+		if (!TPDEV_ISLDT(pn)) continue;
+		strcpy (s, pn->name);
+		s += strlen (s) + 1;
+	}
+	read_unlock (&dev_base_lock);
+	*dlen = s - *devlist;
+	return 0;
+}
+
+ssize_t
+ldt_get_devinfo (tdev, info)
+	struct ldt_dev	*tdev;
+	char						**info;
+{
+	char		*buf=NULL;
+	ssize_t	len, blen;
+
+	if (!tdev) return -EINVAL;
+	if (!ISLDTDEV(tdev)) return -EINVAL;
+	DEV_LOCK_CHK(tdev);
+	blen = get_devinfo (tdev, NULL, 0);
+	if (blen < 0 || !info) {
+		DEV_UNLOCK(tdev);
+		return blen;
+	}
+	buf = kmalloc (blen+1, GFP_KERNEL);
+	*info = buf;
+	if (!buf) {
+		DEV_UNLOCK(tdev);
+		return -ENOMEM;
+	}
+	len = get_devinfo (tdev, buf, blen+1);
+	DEV_UNLOCK(tdev);
+	if (len < 0) return len;
+	if (len > blen) {
+		tp_warn ("write truncated");
+	}
+	return len;
+}
+
+ssize_t
+ldt_get_alldevinfo (net, info)
+	struct net	*net;
+	char			**info;
+{
+	char						*obuf=NULL, *p;
+	ssize_t					len, blen, xlen;
+	struct ldt_dev	*tdev;
+	struct net_device		*pn;
+
+	if (!net || !info) return -EINVAL;
+	len=32;
+	obuf = kmalloc (len, GFP_KERNEL);
+	if (!obuf) return -ENOMEM;
+	strcpy (obuf, "<ldtlist>\n");
+	p = obuf + strlen ("<ldtlist>\n");
+	read_lock (&dev_base_lock);
+	for_each_netdev (net, pn) {
+		if (!TPDEV_ISLDT(pn)) continue;
+		tdev = LDTDEV(pn);
+		if (!tdev) continue;
+		if (!DEV_LOCK_CHK(tdev)) continue;
+		blen = get_devinfo (tdev, NULL, 0);
+		if (blen < 0) {
+			DEV_UNLOCK(tdev);
+			read_unlock (&dev_base_lock);
+			return blen;
+		}
+		len += blen;
+		xlen = p-obuf;
+		p = krealloc (obuf, len, GFP_KERNEL);
+		if (!p) {
+			DEV_UNLOCK(tdev);
+			read_unlock (&dev_base_lock);
+			kfree (obuf);
+			return -ENOMEM;
+		}
+		obuf = p;
+		p += xlen;
+		blen = get_devinfo (tdev, p, blen+1);
+		DEV_UNLOCK(tdev);
+		if (blen < 0) {
+			read_unlock (&dev_base_lock);
+			kfree (obuf);
+			return blen;
+		}
+		p += blen;
+	}
+	read_unlock (&dev_base_lock);
+	strcpy (p, "</ldtlist>\n");
+	p += strlen ("</ldtlist>\n");
+	len = p-obuf;
+	if (info) {
+		*info = obuf;
+	} else {
+		kfree (obuf);
+	}
+	return len;
+}
+
+
+static
+ssize_t
+get_devinfo (tdev, info, ilen)
+	struct ldt_dev	*tdev;
+	char						*info;
+	size_t					ilen;
+{
+	ssize_t	len=0, ret;
+
+	/* lock must be held by caller */
+	if (!ISLDTDEV(tdev) || !ISACTIVE(tdev)) return -EINVAL;
+#define _FSTR	(info ? info + len : NULL)
+#define _FLEN	(ilen > len ? ilen - len : 0)
+	len += snprintf (_FSTR, _FLEN, "<dev name=\"%s\">\n", tdev->ndev->name);
+	len += snprintf (_FSTR, _FLEN, "  <mtu>%d</mtu>\n", (int)tdev->ndev->mtu);
+	len += snprintf (_FSTR, _FLEN, "  <ctime>%lld</ctime><mtime>%lld</mtime>\n",
+												(long long)tdev->ctime, (long long)tdev->mtime);
+	len += snprintf (_FSTR, _FLEN, "  <tun>\n");
+	ret = ldt_tun_gettuninfo (&tdev->tun, _FSTR, _FLEN);
+	if (ret < 0) {
+		tp_warn ("cannot get info from tunnel of device %s: %d",
+					tdev->ndev->name, (int)ret);
+	} else {
+		len += ret;
+	}
+	len += snprintf (_FSTR, _FLEN, "  </tun>\n");
+	len += snprintf (_FSTR, _FLEN, "</dev>\n");
+	return len;
+#undef _FSTR
+#undef _FLEN
+}
+
+
+int
+ldt_rm_tun (tdev)
+	struct ldt_dev	*tdev;
+{	struct timespec64 ts;
+	if (!tdev) return -EINVAL;
+	if (!DEV_LOCK_CHK(tdev)) return -EINVAL;
+	if (tdev->ndev->flags & IFF_UP) {
+		DEV_UNLOCK(tdev);
+		return -EPERM;
+	}
+	SETACTIVE(tdev,0);
+	ldt_rm_tun2 (tdev);
+	//tdev->mtime = get_seconds();
+	ktime_get_raw_ts64(&ts);
+	tdev->mtime = ts.tv_sec;
+	SETACTIVE(tdev,1);
+	DEV_UNLOCK(tdev);
+	return 0;
+}
+
+static
+void
+ldt_rm_tun2 (tdev)
+	struct ldt_dev	*tdev;
+{
+	struct ldt_tun	*tun;
+
+	tun = &tdev->tun;
+	if (tun->tunops)
+		ldt_event_crsend (LDT_EVTYPE_TUNDOWN, tun, 0);
+	ldt_tun_remove (tun);
+	*tun = (struct ldt_tun) { .tdev = tdev };
+	tdev->hastun=0;
+}
+
+
+int
+ldt_dev_newtun (tdev, tuntype)
+	struct ldt_dev	*tdev;
+	const char				*tuntype;
+{
+	int						ret;
+	struct ldt_tun	*tun;
+	struct timespec64 ts;
+	int						mhead;
+
+	if (!DEV_LOCK_CHK(tdev)) return -EINVAL;
+	SETACTIVE(tdev,0);
+	if (tdev->hastun) {
+		ret = -EALREADY;
+		goto out;
+	}
+	tun = (&tdev->tun);
+	*tun = (struct ldt_tun) { .tdev = tdev };
+	ret = ldt_tun_init (tun, tuntype);
+	if (ret < 0)  goto out;
+	mhead = ldt_tun_needheadroom (tun);
+	if (mhead > 0 && tdev->ndev->needed_headroom < mhead) tdev->ndev->needed_headroom = mhead;
+	tdev->hastun = 1;
+	//tdev->mtime = get_seconds();
+	ktime_get_raw_ts64(&ts);
+	tdev->mtime = ts.tv_sec;
+	ldt_event_crsend (LDT_EVTYPE_TUNUP, tun, 0);
+out:
+	SETACTIVE(tdev,1);
+	DEV_UNLOCK(tdev);
+	return ret;
+}
+
+int
+ldt_dev_bind2dev (tdev, dev)
+	struct ldt_dev	*tdev;
+	const char				*dev;
+{
+	struct net_device	*ndev;
+	int					ret;
+
+	if (!tdev || !dev) return -EINVAL;
+	ndev = dev_get_by_name (TDEV2NET(tdev), dev);
+	if (!ndev) return -ENOENT;
+	if (!DEV_LOCK_CHK(tdev)) {
+		dev_put (ndev);
+		return -EINVAL;
+	}
+	if (tdev->pdev) dev_put (tdev->pdev);
+	tdev->pdev = ndev;
+	ret = ldt_tun_rebind (&tdev->tun, 0);
+	tdev->tun.pdevdown=0;
+	DEV_UNLOCK(tdev);
+	return ret;
+}
+
+int
+ldt_dev_bind (tdev, laddr)
+	struct ldt_dev	*tdev;
+	tp_addr_t				*laddr;
+{
+	int	ret;
+
+	if (!DEV_LOCK_CHK(tdev)) return -EINVAL;
+	ret = ldt_tun_bind (&tdev->tun, laddr);
+	DEV_UNLOCK(tdev);
+	return ret;
+}
+
+int
+ldt_dev_peer (tdev, raddr)
+	struct ldt_dev	*tdev;
+	tp_addr_t				*raddr;
+{
+	int	ret;
+
+	if (!DEV_LOCK_CHK(tdev)) return -EINVAL;
+	ret = ldt_tun_peer (&tdev->tun, raddr);
+	DEV_UNLOCK(tdev);
+	return ret;
+}
+
+int
+ldt_dev_serverstart (tdev)
+	struct ldt_dev	*tdev;
+{
+	int	ret;
+
+	if (!DEV_LOCK_CHK(tdev)) return -EINVAL;
+	ret = ldt_tun_serverstart (&tdev->tun);
+	DEV_UNLOCK(tdev);
+	return ret;
+}
+
+int
+ldt_dev_setqueue (tdev, txlen, qpolicy)
+	struct ldt_dev	*tdev;
+	int						txlen, qpolicy;
+{
+	int	ret;
+
+	if (!DEV_LOCK_CHK(tdev)) return -EINVAL;
+	ret = ldt_tun_setqueue (&tdev->tun, txlen, qpolicy);
+	DEV_UNLOCK(tdev);
+	return ret;
+}
+
+
+int
+ldt_dev_set_mtu (tdev, mtu)
+	struct ldt_dev	*tdev;
+	int						mtu;
+{
+	/* locking is done by tpdev_change_mtu */
+	if (!tdev || !tdev->ndev) return -EINVAL;
+	if (!ISLDTDEV(tdev)) return -EINVAL;
+	return tpdev_change_mtu (tdev->ndev, mtu);
+}
+
+int
+ldt_dev_evsend (tdev, evtype, reason)
+	struct ldt_dev	*tdev;
+	int				evtype;
+	int				reason;
+{
+	int	kind, ret;
+
+	if (!DEV_LOCK_CHK(tdev)) return -EINVAL;
+	ret = kind = ldt_event_getkind (evtype);
+	if (ret<0) goto out;
+	switch (kind) {
+	case TP_EVKIND_GLOBAL:
+		ret = ldt_event_crsend (evtype, NULL, reason);
+		break;
+	case TP_EVKIND_TDEV:
+		ret = ldt_event_crsend (evtype, tdev, reason);
+		break;
+	case TP_EVKIND_TUN:
+	case TP_EVKIND_TUNCONNECT:
+	case TP_EVKIND_TUNFAIL:
+		ret = ldt_event_crsend (evtype, &tdev->tun, reason);
+		break;
+	case TP_EVKIND_NDEV:
+		ret = ldt_event_crsend (evtype, tdev->ndev, reason);
+		break;
+	default:
+		ret = -EOPNOTSUPP;
+		break;
+	}
+out:
+	DEV_UNLOCK(tdev);
+	return ret;
+}
+
+
+/* **************************************
+ * watch physical device
+ * **************************************/
+
+static
+int
+tpdev_ndevup (tdev)
+	struct ldt_dev	*tdev;
+{
+	int	ret;
+
+	if (!DEV_LOCK_CHK(tdev)) return -EINVAL;
+	ret = ldt_tun_rebind (&tdev->tun, LDT_TUN_BIND_F_ADDRCHG);
+	tdev->tun.pdevdown=0;
+	ldt_event_crsend (LDT_EVTYPE_PDEVUP, &tdev->tun, 0);
+	DEV_UNLOCK(tdev);
+	return ret;
+}
+
+static
+int
+tpdev_ndevdown (tdev)
+	struct ldt_dev	*tdev;
+{
+	if (!DEV_LOCK_CHK(tdev)) return -EINVAL;
+	tdev->tun.pdevdown=1;
+	ldt_event_crsend (LDT_EVTYPE_PDEVDOWN, &tdev->tun, 0);
+	DEV_UNLOCK(tdev);
+	return 0;
+}
+
+
+
+
+
+
+static
+int
+tp_ev_up (ndev)
+	struct net_device	*ndev;
+{
+	struct ldt_dev	*p;
+	struct net_device		*pn;
+	struct net				*net;
+	int						found=0;
+
+	if (!ndev) return -EINVAL;
+	ldt_event_crsend (LDT_EVTYPE_NIFUP, ndev, 0);
+	net = NDEV2NET(ndev);
+	read_lock (&dev_base_lock);
+	for_each_netdev (net, pn) {
+		if (!TPDEV_ISLDT(pn)) continue;
+		p = LDTDEV(pn);
+		if (!p) continue;
+		if (ndev == p->pdev) {
+			dev_hold (p->ndev);
+			found=1;
+			break;
+		}
+	}
+	read_unlock (&dev_base_lock);
+	if (found) {
+		tpdev_ndevup (p);
+		dev_put (p->ndev);
+	}
+	return 0;
+}
+
+static
+int
+tp_ev_down (ndev)
+	struct net_device	*ndev;
+{
+	struct ldt_dev	*p;
+	struct net_device		*pn;
+	struct net				*net;
+	int						found=0;
+
+	if (!ndev) return -EINVAL;
+	ldt_event_crsend (LDT_EVTYPE_NIFDOWN, ndev, 0);
+	net = NDEV2NET(ndev);
+	read_lock (&dev_base_lock);
+	for_each_netdev (net, pn) {
+		if (!TPDEV_ISLDT(pn)) continue;
+		p = LDTDEV(pn);
+		if (!p) continue;
+		if (ndev == p->pdev) {
+			dev_hold (p->ndev);
+			found=1;
+			break;
+		}
+	}
+	read_unlock (&dev_base_lock);
+	if (found) {
+		tpdev_ndevdown (p);
+		dev_put (p->ndev);
+	}
+	return 0;
+}
+
+static
+int
+tp_ev_register (
+	struct net_device	*ndev)
+{
+	struct ldt_dev	*tdev;
+	struct timespec64 ts;
+
+	if (!ndev) return -EINVAL;
+	if (!TPDEV_ISLDT (ndev)) return 0;
+	tp_debug ("finish tp device registration");
+	tdev = LDTDEV (ndev);
+	if (!tdev) return -EINVAL;
+	//tdev->ctime = tdev->mtime = get_seconds();
+	ktime_get_raw_ts64(&ts);
+	tdev->ctime = tdev->mtime = ts.tv_sec;
+	SETACTIVE(tdev,1);
+	ldt_event_crsend (LDT_EVTYPE_IFUP, tdev, 0);
+	/* we are done */
+	tp_info ("ldt device >>%s<< successfully created\n", ndev->name);
+	return 0;
+}
+
+
+static
+int
+tp_ev_ndev (nblk, event, ptr)
+	struct notifier_block	*nblk;
+	unsigned long				event;
+	void							*ptr;
+{
+	struct net_device			*ndev;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0)
+	ndev = netdev_notifier_info_to_dev (ptr);
+#else
+	ndev = (struct net_device *)ptr;
+#endif
+	if (!ndev) return NOTIFY_DONE;
+	tp_debug ("watch dev >>%s<< triggered event %lu\n", ndev->name, event);
+	switch (event) {
+	case NETDEV_DOWN:
+		tp_ev_down (ndev);
+		break;
+	case NETDEV_UP:
+		tp_ev_up (ndev);
+		break;
+	case NETDEV_REGISTER:
+		tp_ev_register (ndev);
+		break;
+	}
+	return NOTIFY_DONE;
+}
+
+
+
+
+
+
+
+
+
+
+/*
+ * Overrides for XEmacs and vim so that we get a uniform tabbing style.
+ * XEmacs/vim will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 3
+ * c-basic-offset: 3
+ * tab-width: 3
+ * End:
+ * vim:tw=0:ts=3:wm=0:
+ */
+
+
+
+
+
+
+
+
+
+
+
+
+/*
+ * Overrides for XEmacs and vim so that we get a uniform tabbing style.
+ * XEmacs/vim will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 3
+ * c-basic-offset: 3
+ * tab-width: 3
+ * End:
+ * vim:tw=0:ts=3:wm=0:
+ */
diff --git a/net/ldt/ldt_dev.h b/net/ldt/ldt_dev.h
new file mode 100644
index 0000000000000..6222590b9ca23
--- /dev/null
+++ b/net/ldt/ldt_dev.h
@@ -0,0 +1,193 @@
+/*
+ * Copyright (C) 2015-2022 by Frank Reker, Deutsche Telekom AG
+ *
+ * LDT - Lightweight (MP-)DCCP Tunnel kernel module
+ *
+ * This is not Open Source software.
+ * This work is made available to you under a source-available license, as
+ * detailed below.
+ *
+ * Copyright 2022 Deutsche Telekom AG
+ *
+ * Permission is hereby granted, free of charge, subject to below Commons
+ * Clause, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * “Commons Clause” License Condition v1.0
+ *
+ * The Software is provided to you by the Licensor under the License, as
+ * defined below, subject to the following condition.
+ *
+ * Without limiting other conditions in the License, the grant of rights under
+ * the License will not include, and the License does not grant to you, the
+ * right to Sell the Software.
+ *
+ * For purposes of the foregoing, “Sell” means practicing any or all of the
+ * rights granted to you under the License to provide to third parties, for a
+ * fee or other consideration (including without limitation fees for hosting
+ * or consulting/ support services related to the Software), a product or
+ * service whose value derives, entirely or substantially, from the
+ * functionality of the Software. Any license notice or attribution required
+ * by the License must also include this Commons Clause License Condition
+ * notice.
+ *
+ * Licensor: Deutsche Telekom AG
+ */
+
+#ifndef _R__KERNEL_LDT_DEV_H
+#define _R__KERNEL_LDT_DEV_H
+
+#include <linux/types.h>
+#include <linux/netdevice.h>
+
+#include "ldt_addr.h"
+#include "ldt_debug.h"
+#include "ldt_tun.h"
+#include "ldt_lock.h"
+
+
+#define LDT_MAGIC		((u32)(0xa0ec9374L))
+struct ldt_dev {
+	u32						MAGIC;
+	struct hlist_node		list;
+	struct net_device		*ndev;
+	struct net_device		*pdev;
+	struct tp_lock			lock;
+	u32						active;
+	u32						hastun:1,
+								client:1,
+								server:1;
+	unsigned long					ctime,mtime;
+	struct ldt_tun			tun;
+};
+
+
+#define ISLDTDEV(tdev) ((tdev) && ((tdev)->MAGIC == LDT_MAGIC) \
+										&& ((tdev)->ndev))
+#define ISLDTDEV2(tdev,_ndev)	(ISLDTDEV(tdev) && (tdev)->ndev == (_ndev))
+#define ISACTIVE(tdev) (smp_load_acquire (&((tdev)->active)))
+#define ISACTIVETPDEV(tdev) (ISLDTDEV(tdev) && ISACTIVE(tdev))
+#define ISLDTNDEV(ndev) (LDTDEV2(ndev) != NULL)
+#define TPDEV_ISLDT(ndev) ((ndev)->dev.type && (ndev)->dev.type->name && \
+					!strcmp (ndev->dev.type->name, "ldt") && ISLDTNDEV(ndev))
+
+static inline int TDEV_HOLDACTIVE(struct ldt_dev *tdev)
+{
+	if (!ISACTIVETPDEV(tdev)) return 0;
+	dev_hold (tdev->ndev);
+	if (!ISACTIVETPDEV(tdev)) {
+		dev_put (tdev->ndev);
+		return 0;
+	}
+	return 1;
+}
+#define TDEV_PUT(tdev)	do { if (ISLDTDEV(tdev)) dev_put ((tdev)->ndev); } while (0)
+
+#define NDEV2NET(ndev)	((ndev)?read_pnet(&((ndev)->nd_net)):(void*)0)
+#define TDEV2NET(tdev)	((tdev)?NDEV2NET((tdev)->ndev):(void*)0)
+
+
+static
+inline
+struct ldt_dev *
+LDTDEV (struct net_device	*ndev)
+{
+	struct ldt_dev	*tdev;
+	if (!ndev) return NULL;
+	tdev = (struct ldt_dev*) netdev_priv (ndev);
+	if (!ISLDTDEV2(tdev,ndev)) {
+		tp_note ("netdevice >>%s<< not a ldt device", ndev->name);
+		return NULL;
+	}
+	return tdev;
+};
+static
+inline
+struct ldt_dev *
+LDTDEV2 (struct net_device	*ndev)
+{
+	struct ldt_dev	*tdev;
+	if (!ndev) return NULL;
+	tdev = (struct ldt_dev*) netdev_priv (ndev);
+	if (!ISLDTDEV2(tdev,ndev)) return NULL;
+	return tdev;
+};
+
+
+/* Note: calling LDTDEV_BYNAME needs
+ *			a dev_put to release the device
+ */
+static
+inline
+struct ldt_dev *
+LDTDEV_BYNAME (struct net *net, const char *name)
+{
+	struct ldt_dev	*tdev;
+	struct net_device		*ndev = dev_get_by_name (net, name);
+	if (!ndev) {
+		tp_note ("invalid netdevice >>%s<<", name);
+		return NULL;
+	}
+	tdev = LDTDEV (ndev);
+	if (!tdev) dev_put (ndev);
+	return tdev;
+};
+
+
+int ldt_dev_global_init (void);
+void ldt_dev_global_destroy (void);
+
+int ldt_create_dev (struct net*, const char *name,
+								const char **out_name, int flags);
+void ldt_free_dev (struct ldt_dev *tdev);
+int ldt_dev_set_group (struct ldt_dev*, const char *name);
+
+int ldt_dev_set_mtu (struct ldt_dev *tdev, int mtu);
+
+int ldt_get_devlist (struct net *net, char**devlist, u32 *dlen);
+ssize_t ldt_get_devinfo (struct ldt_dev *tdev, char **info);
+ssize_t ldt_get_alldevinfo (struct net *net, char **info);
+
+int ldt_rm_tun (struct ldt_dev *tdev);
+int ldt_dev_newtun (struct ldt_dev *tdev, const char *tuntype);
+int ldt_dev_bind (struct ldt_dev *tdev, tp_addr_t *laddr);
+int ldt_dev_bind2dev (	struct ldt_dev *tdev, const char *dev);
+int ldt_dev_peer (struct ldt_dev *tdev, tp_addr_t *raddr);
+int ldt_dev_serverstart (struct ldt_dev *tdev);
+int ldt_dev_setqueue (struct ldt_dev*, int txlen, int qpolicy);
+
+
+int ldt_dev_evsend (struct ldt_dev *tdev, int evtype, int reason);
+
+
+
+#endif	/* _R__KERNEL_LDT_DEV_H */
+
+/*
+ * Overrides for XEmacs and vim so that we get a uniform tabbing style.
+ * XEmacs/vim will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 3
+ * c-basic-offset: 3
+ * tab-width: 3
+ * End:
+ * vim:tw=0:ts=3:wm=0:
+ */
diff --git a/net/ldt/ldt_event.c b/net/ldt/ldt_event.c
new file mode 100644
index 0000000000000..e04c1c1c2634c
--- /dev/null
+++ b/net/ldt/ldt_event.c
@@ -0,0 +1,316 @@
+/*
+ * Copyright (C) 2015-2022 by Frank Reker, Deutsche Telekom AG
+ *
+ * LDT - Lightweight (MP-)DCCP Tunnel kernel module
+ *
+ * This is not Open Source software.
+ * This work is made available to you under a source-available license, as
+ * detailed below.
+ *
+ * Copyright 2022 Deutsche Telekom AG
+ *
+ * Permission is hereby granted, free of charge, subject to below Commons
+ * Clause, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * “Commons Clause” License Condition v1.0
+ *
+ * The Software is provided to you by the Licensor under the License, as
+ * defined below, subject to the following condition.
+ *
+ * Without limiting other conditions in the License, the grant of rights under
+ * the License will not include, and the License does not grant to you, the
+ * right to Sell the Software.
+ *
+ * For purposes of the foregoing, “Sell” means practicing any or all of the
+ * rights granted to you under the License to provide to third parties, for a
+ * fee or other consideration (including without limitation fees for hosting
+ * or consulting/ support services related to the Software), a product or
+ * service whose value derives, entirely or substantially, from the
+ * functionality of the Software. Any license notice or attribution required
+ * by the License must also include this Commons Clause License Condition
+ * notice.
+ *
+ * Licensor: Deutsche Telekom AG
+ */
+
+#include <linux/socket.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/netlink.h>
+#include <net/sock.h>
+#include <net/tcp_states.h>
+#include <linux/skbuff.h>
+#include <linux/version.h>
+
+
+#include "ldt_uapi.h"
+#include "ldt_dev.h"
+#include "ldt_tun.h"
+#include "ldt_debug.h"
+#include "ldt_netlink.h"
+#include "ldt_event.h"
+
+
+
+
+
+int
+ldt_event_send (net, evtype, iarg, sarg)
+	struct net						*net;
+	enum ldt_event_type		evtype;
+	u32								iarg;
+	const char						*sarg;
+{
+	return ldt_nl_send_event (net, (u32)evtype, iarg, sarg);
+}
+
+
+
+int
+ldt_event_crsend2 (tun, evtype, evstype, desc)
+	struct ldt_tun	*tun;
+	int						evtype;
+	const char				*evstype, *desc;
+{
+	char			_buf[256], *buf;
+	int			ret, len;
+	const char	*name;
+
+	if (!tun || !evstype || evtype < 0) return -EINVAL;
+	if (!desc) desc="";
+	name = ((tun->tdev && tun->tdev->ndev) ?  tun->tdev->ndev->name : "");
+	if (!name) name="";
+	tp_debug2 ("event >>%s<<: %s (%s)", evstype, desc,
+				(*name?name:"<unknown>"));
+	if (TUNIFFUNC(tun,tp_createvent)) {
+		len = ret = ldt_tun_createvent (tun, _buf, sizeof (_buf),
+														evstype, desc);
+		if (ret < 0) goto simplevent;
+		len++;
+		if (len > sizeof(_buf)) {
+			if (in_atomic()) {
+				buf = kmalloc (len+1, GFP_ATOMIC);
+			} else {
+				buf = kmalloc (len+1, GFP_KERNEL);
+			}
+			if (!buf) goto simplevent;
+			ret = ldt_tun_createvent (tun, buf, len, evstype, desc);
+			if (ret < 0) {
+				kfree (buf);
+				goto simplevent;
+			}
+		} else {
+			buf = _buf;
+		}
+	} else {
+simplevent:
+		snprintf (_buf, sizeof (_buf)-1, "<event type=\"%s\">\n"
+					"  <desc>%s</desc>\n"
+					"  <iface>%s</iface>\n"
+					"</event>\n", evstype, desc, name);
+		_buf[sizeof(_buf)-1]=0;
+		buf = _buf;
+	}
+	tp_debug3 ("event: %s\n", buf);
+	ret = ldt_event_send (TUN2NET(tun), evtype, 0, buf);
+	if (ret < 0)
+		tp_err ("error sending event: %d\n", ret);
+	if (buf && buf != _buf) kfree (buf);
+
+	return ret;
+}
+
+
+#define TP_EVKIND_GLOBAL		1
+#define TP_EVKIND_TDEV			2
+#define TP_EVKIND_TUN			3
+#define TP_EVKIND_TUNCONNECT	4
+#define TP_EVKIND_NDEV			5
+#define TP_EVKIND_TUNFAIL		6
+struct evinfo {
+	int			evtype;
+	const char	*evstr;
+	const char	*desc;
+	int			kind;
+};
+static int ldt_event_getinfo (struct evinfo**, int);
+
+struct evinfo	evlist[] = {
+	{ LDT_EVTYPE_UNSPEC, "unspec", "not specified", TP_EVKIND_GLOBAL },
+	{ LDT_EVTYPE_INIT, "init", "init handshake successfull", TP_EVKIND_TUNCONNECT },
+	{ LDT_EVTYPE_DOWN, "down", "remote host down", TP_EVKIND_TUNCONNECT },
+	{ LDT_EVTYPE_UP, "up", "remote host up", TP_EVKIND_TUNCONNECT },
+	{ LDT_EVTYPE_TUNDOWN, "tundown", "tunnel brought down", TP_EVKIND_TUN },
+	{ LDT_EVTYPE_TUNUP, "tunup", "new tunnel brought up", TP_EVKIND_TUN },
+	{ LDT_EVTYPE_IFDOWN, "ifdown", "interface brought down", TP_EVKIND_TDEV },
+	{ LDT_EVTYPE_IFUP, "ifup", "new interface brought up", TP_EVKIND_TDEV },
+	{ LDT_EVTYPE_TPDOWN, "tpdown", "ldt module unloaded", TP_EVKIND_GLOBAL },
+	{ LDT_EVTYPE_PDEVDOWN, "pdevdown", "(underlying) physical device down", TP_EVKIND_TUN },
+	{ LDT_EVTYPE_PDEVUP, "pdevup", "(underlying) physical device up", TP_EVKIND_TUN },
+	{ LDT_EVTYPE_NIFDOWN, "nifdown", "network interface down", TP_EVKIND_NDEV },
+	{ LDT_EVTYPE_NIFUP, "nifup", "network interface up", TP_EVKIND_NDEV },
+	{ LDT_EVTYPE_REBIND, "rebind", "tunnel was rebound", TP_EVKIND_TUNCONNECT },
+	{ LDT_EVTYPE_SUBFLOW_UP, "subflowup", "new subflow added", TP_EVKIND_TUNCONNECT },
+	{ LDT_EVTYPE_SUBFLOW_DOWN, "subflowdown", "subflow removed", TP_EVKIND_TUNCONNECT },
+	{ LDT_EVTYPE_CONN_ESTAB, "connestab", "connection established", TP_EVKIND_TUNCONNECT },
+	{ LDT_EVTYPE_CONN_ESTAB_FAIL, "connestabfail", "connection establishment failed", TP_EVKIND_TUNFAIL },
+	{ LDT_EVTYPE_CONN_ACCEPT, "connaccept", "connection accepted", TP_EVKIND_TUNCONNECT },
+	{ LDT_EVTYPE_CONN_ACCEPT_FAIL, "connacceptfail", "connection failed to accept", TP_EVKIND_TUNFAIL },
+	{ LDT_EVTYPE_CONN_LISTEN, "connlisten", "server listening", TP_EVKIND_TUNCONNECT },
+	{ LDT_EVTYPE_CONN_LISTEN_FAIL, "connlistenfail", "failed to listen", TP_EVKIND_TUNFAIL },
+	{ -1, "unknown", "unknown event", TP_EVKIND_GLOBAL }};
+#define TP_EVLIST_SZ	26
+
+static
+int
+ldt_event_getinfo (evinfo, evtype)
+	struct evinfo	**evinfo;
+	int				evtype;
+{
+	struct evinfo	*p=NULL;
+
+	if (evtype < 0 || evtype > LDT_EVTYPE_MAX) return -ERANGE;
+	if (evtype <= TP_EVLIST_SZ && evlist[evtype].evtype == evtype) {
+		p = evlist + evtype;
+	} else {
+		for (p=evlist; p->evtype >= 0; p++) {
+			if (p->evtype == evtype) break;
+		}
+	}
+	if (evinfo) *evinfo = p;
+	if (!p) return -ENOENT;
+	return 0;
+}
+
+int
+ldt_event_getkind (evtype)
+	int	evtype;
+{
+	struct evinfo	*p=NULL;
+	int				ret;
+
+	ret = ldt_event_getinfo (&p, evtype);
+	if (ret < 0) return ret;
+	return p ? p->kind : -ENOENT;
+}
+
+int
+ldt_event_crsend (evtype, dat, reason)
+	int	evtype;
+	void	*dat;
+	int	reason;
+{
+	int						kind, ret;
+	struct evinfo			*p=NULL;
+	struct ldt_tun			*tun;
+	struct ldt_dev			*tdev;
+	struct net_device		*ndev;
+	char						buf[256], *buf2 = buf;
+	struct net				*net;
+
+	ret = ldt_event_getinfo (&p, evtype);
+	if (ret < 0) return ret;
+	kind = dat ? p->kind : TP_EVKIND_GLOBAL;
+	switch (kind) {
+	case TP_EVKIND_GLOBAL:
+	default:
+		snprintf (buf, sizeof (buf)-1, "<event type=\"%s\">\n"
+					"  <desc>%s</desc>\n"
+					"</event>\n", p->evstr, p->desc);
+		buf[sizeof(buf)-1]=0;
+		net=0;
+		break;
+	case TP_EVKIND_TDEV:
+		tdev = (struct ldt_dev*)dat;
+		snprintf (buf, sizeof (buf)-1, "<event type=\"%s\">\n"
+					"  <desc>%s</desc>\n"
+					"  <iface>%s</iface>\n"
+					"</event>\n",
+					p->evstr, p->desc, tdev->ndev->name);
+		buf[sizeof(buf)-1]=0;
+		net = TDEV2NET(tdev);
+		break;
+	case TP_EVKIND_NDEV:
+		ndev = (struct net_device*)dat;
+		snprintf (buf, sizeof (buf)-1, "<event type=\"%s\">\n"
+					"  <desc>%s</desc>\n"
+					"  <iface>%s</iface>\n"
+					"</event>\n", p->evstr, p->desc, ndev->name);
+		buf[sizeof(buf)-1]=0;
+		net = NDEV2NET(ndev);
+		break;
+	case TP_EVKIND_TUN:
+		tun = (struct ldt_tun*)dat;
+		tdev = tun->tdev;
+		snprintf (buf, sizeof (buf)-1, "<event type=\"%s\">\n"
+					"  <desc>%s</desc>\n"
+					"  <iface>%s</iface>\n"
+					"%s%s%s"
+					"</event>\n", p->evstr, p->desc, tdev->ndev->name,
+					(tun->tdev->pdev?"  <pdev>":""),
+					(tun->tdev->pdev ? tun->tdev->pdev->name : ""),
+					(tun->tdev->pdev?"</pdev>\n":""));
+		buf[sizeof(buf)-1]=0;
+		net = TDEV2NET(tdev);
+		break;
+	case TP_EVKIND_TUNCONNECT:
+		tun = (struct ldt_tun*)dat;
+		net = TUN2NET(tun);
+		return ldt_event_crsend2 (tun, evtype, p->evstr, p->desc);
+	case TP_EVKIND_TUNFAIL:
+		tun = (struct ldt_tun*)dat;
+		tdev = tun->tdev;
+		snprintf (buf, sizeof (buf)-1, "<event type=\"%s\">\n"
+					"  <desc>%s</desc>\n"
+					"  <iface>%s</iface>\n"
+					"  <reason>%d</reason>\n"
+					"</event>\n", p->evstr, p->desc, tdev->ndev->name,
+					reason);
+		buf[sizeof(buf)-1]=0;
+		net = TDEV2NET(tdev);
+		break;
+	}
+	tp_debug3 ("event: %s\n", buf2);
+	ret = ldt_event_send (net, evtype, 0, buf2);
+	if (ret < 0)
+		tp_err ("error sending event: %d\n", ret);
+	if (buf2 != buf) kfree (buf2);
+	return 0;
+}
+
+
+
+
+
+
+
+
+/*
+ * Overrides for XEmacs and vim so that we get a uniform tabbing style.
+ * XEmacs/vim will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 3
+ * c-basic-offset: 3
+ * tab-width: 3
+ * End:
+ * vim:tw=0:ts=3:wm=0:
+ */
diff --git a/net/ldt/ldt_event.h b/net/ldt/ldt_event.h
new file mode 100644
index 0000000000000..d342d6f05fbac
--- /dev/null
+++ b/net/ldt/ldt_event.h
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2015-2022 by Frank Reker, Deutsche Telekom AG
+ *
+ * LDT - Lightweight (MP-)DCCP Tunnel kernel module
+ *
+ * This is not Open Source software.
+ * This work is made available to you under a source-available license, as
+ * detailed below.
+ *
+ * Copyright 2022 Deutsche Telekom AG
+ *
+ * Permission is hereby granted, free of charge, subject to below Commons
+ * Clause, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * “Commons Clause” License Condition v1.0
+ *
+ * The Software is provided to you by the Licensor under the License, as
+ * defined below, subject to the following condition.
+ *
+ * Without limiting other conditions in the License, the grant of rights under
+ * the License will not include, and the License does not grant to you, the
+ * right to Sell the Software.
+ *
+ * For purposes of the foregoing, “Sell” means practicing any or all of the
+ * rights granted to you under the License to provide to third parties, for a
+ * fee or other consideration (including without limitation fees for hosting
+ * or consulting/ support services related to the Software), a product or
+ * service whose value derives, entirely or substantially, from the
+ * functionality of the Software. Any license notice or attribution required
+ * by the License must also include this Commons Clause License Condition
+ * notice.
+ *
+ * Licensor: Deutsche Telekom AG
+ */
+
+#ifndef _R__KERNEL_TP_EVENT_H
+#define _R__KERNEL_TP_EVENT_H
+
+#include "ldt_uapi.h"
+
+
+
+struct net;
+int ldt_event_send (struct net*, enum ldt_event_type, u32 iarg, const char *sarg);
+struct ldt_tun;
+int ldt_event_crsend2 (struct ldt_tun*, int evtype, const char *evstype,
+									const char *desc);
+
+/* dat must be of type ldt_dev for:
+	LDT_EVTYPE_IFDOWN and LDT_EVTYPE_IFUP
+	otherwise ldt_tun or NULL
+ */
+int ldt_event_crsend (int evtype, void *dat, int reason);
+
+#define TP_EVKIND_GLOBAL		1		/* needs NULL */
+#define TP_EVKIND_TDEV			2		/* needs struct ldt_dev */
+#define TP_EVKIND_TUN			3		/* needs struct ldt_tun */
+#define TP_EVKIND_TUNCONNECT	4		/* needs struct ldt_tun */
+#define TP_EVKIND_NDEV			5		/* needs struct net_device */
+#define TP_EVKIND_TUNFAIL		6		/* needs struct ldt_tun */
+
+int ldt_event_getkind (int evtype);
+
+
+#endif	/* _R__KERNEL_TP_EVENT_H */
+
+/*
+ * Overrides for XEmacs and vim so that we get a uniform tabbing style.
+ * XEmacs/vim will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 3
+ * c-basic-offset: 3
+ * tab-width: 3
+ * End:
+ * vim:tw=0:ts=3:wm=0:
+ */
diff --git a/net/ldt/ldt_ip.c b/net/ldt/ldt_ip.c
new file mode 100644
index 0000000000000..b6e34fc6ab1eb
--- /dev/null
+++ b/net/ldt/ldt_ip.c
@@ -0,0 +1,250 @@
+/*
+ * Copyright (C) 2015-2022 by Frank Reker, Deutsche Telekom AG
+ *
+ * LDT - Lightweight (MP-)DCCP Tunnel kernel module
+ *
+ * This is not Open Source software.
+ * This work is made available to you under a source-available license, as
+ * detailed below.
+ *
+ * Copyright 2022 Deutsche Telekom AG
+ *
+ * Permission is hereby granted, free of charge, subject to below Commons
+ * Clause, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * “Commons Clause” License Condition v1.0
+ *
+ * The Software is provided to you by the Licensor under the License, as
+ * defined below, subject to the following condition.
+ *
+ * Without limiting other conditions in the License, the grant of rights under
+ * the License will not include, and the License does not grant to you, the
+ * right to Sell the Software.
+ *
+ * For purposes of the foregoing, “Sell” means practicing any or all of the
+ * rights granted to you under the License to provide to third parties, for a
+ * fee or other consideration (including without limitation fees for hosting
+ * or consulting/ support services related to the Software), a product or
+ * service whose value derives, entirely or substantially, from the
+ * functionality of the Software. Any license notice or attribution required
+ * by the License must also include this Commons Clause License Condition
+ * notice.
+ *
+ * Licensor: Deutsche Telekom AG
+ */
+
+
+#include <linux/kernel.h>
+#include <net/sock.h>
+#include <linux/errno.h>
+#include <linux/in6.h>
+#include <linux/in.h>
+#include <linux/types.h>
+#include <linux/netdevice.h>
+#include <linux/ip.h>
+#include <linux/err.h>
+
+#include "ldt_ip.h"
+#include "ldt_prot1.h"
+
+static int getipv4msglen (char*, int);
+static int getipv6msglen (char*, int);
+static int getipv6exthdrlen (int, char*, int, int*);
+
+
+
+int
+ldt_msglen (buf, len)
+	char	*buf;
+	int	len;
+{
+	if (!buf || len < 0) return -EINVAL;
+	if (len < 4) return -EMSGSIZE;
+	switch (TP_GETPKTTYPE (buf[0])) {
+	case 4:
+		return getipv4msglen (buf, len);
+	case 6:
+		return getipv6msglen (buf, len);
+	case 1:
+		return ldt_prot1msglen (buf, len);
+	default:
+		return -EBADMSG;
+	}
+}
+
+
+static
+int
+getipv4msglen (buf, len)
+	char	*buf;
+	int	len;
+{
+	if (!buf || len < 0) return -EINVAL;
+	if (len < 4) return -EMSGSIZE;
+	return (int)(u32) htons (*(u16*)(buf+2));
+}
+
+static
+int
+getipv6msglen (buf, len)
+	char	*buf;
+	int	len;
+{
+	if (!buf || len < 0) return -EINVAL;
+	if (len < 6) return -EMSGSIZE;
+	return (int) (40 + (u32) htons (*(u16*)(buf+4)));
+}
+
+
+
+int
+ldt_iphdrlen (data, sz, l4prot)
+	char	*data;
+	int	sz;
+	int	*l4prot;
+{
+	if (!data || sz < 0) return -EINVAL;
+	if (sz == 0) return 0;
+	switch (TP_GETPKTTYPE(data[0])) {
+	case 1: return sz;
+	case 4: return ldt_ipv4hdrlen (data, sz, l4prot);
+	case 6: return ldt_ipv6hdrlen (data, sz, l4prot);
+	}
+	return sz;
+}
+
+int
+ldt_ipv4hdrlen (data, sz, l4prot)
+	char	*data;
+	int	sz;
+	int	*l4prot;
+{
+	int	len;
+
+	if (!data || sz < 0) return -EINVAL;
+	if (sz < 20) return sz;
+	len = (data[0] & 0x0f) << 2;
+	if (sz < len) return sz;
+	if (l4prot) *l4prot = ((unsigned)(u8)(data[9]));
+	return len;
+}
+
+
+int
+ldt_ipv6hdrlen (data, sz, l4prot)
+	char	*data;
+	int	sz;
+	int	*l4prot;
+{
+	int	ret;
+
+	if (!data || sz < 0) return -EINVAL;
+	if (sz < 40) return sz;
+	ret = getipv6exthdrlen ((unsigned)data[6], data+40, sz-40, l4prot);
+	if (ret < 0) return ret;
+	return ret + 40;
+}
+
+
+static
+int
+getipv6exthdrlen (prot, data, sz, l4prot)
+	int	prot, sz, *l4prot;
+	char	*data;
+{
+	int	ret, len;
+
+	if (!data || sz < 0) return -EINVAL;
+	switch (prot) {
+	case 0: /* hop by hop */
+	case 43: /* routing */
+	case 60: /* destination options */
+		if (sz < 2) return sz;
+		len = (((unsigned)data[1]) << 3) + 1;
+		prot = (unsigned)data[0];
+		if (sz < len) return sz;
+		ret = getipv6exthdrlen (prot, data+len, sz-len, l4prot);
+		if (ret < 0) return ret;
+		return len + ret;
+	case 44: /* fragment */
+		prot = (unsigned)data[0];
+		if (sz < 8) return sz;
+		ret = getipv6exthdrlen (prot, data+8, sz-8, l4prot);
+		if (ret < 0) return ret;
+		return 8 + ret;
+	case 51: /* authentication */
+		/* to be done ... */
+	case 50: /* esp */
+	case 135: /* mobility */
+	case 59: /* end of header */
+	default:
+		if (l4prot) *l4prot = prot;
+		return 0;
+	}
+	return sz;
+}
+
+int
+ldt_l4hdrlen (prot, data, sz)
+	int	prot, sz;
+	char	*data;
+{
+	if (!data || sz < 0) return -EINVAL;
+	switch (prot) {
+	case 6: /* TCP */
+		if (sz < 12) return -EBADMSG;
+		return (((u8)data[12]) & 0xf0) >> 2;
+	case 17: /* UDP */
+	case 136: /* UDPLite */
+		return 8;
+	case 33: /* DCCP */
+		if (sz < 4) return -EBADMSG;
+		return ((unsigned)(u8)(data[4])) << 2;
+	}
+	return sz;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+/*
+ * Overrides for XEmacs and vim so that we get a uniform tabbing style.
+ * XEmacs/vim will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 3
+ * c-basic-offset: 3
+ * tab-width: 3
+ * End:
+ * vim:tw=0:ts=3:wm=0:
+ */
diff --git a/net/ldt/ldt_ip.h b/net/ldt/ldt_ip.h
new file mode 100644
index 0000000000000..ce4c37213cf99
--- /dev/null
+++ b/net/ldt/ldt_ip.h
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2015-2022 by Frank Reker, Deutsche Telekom AG
+ *
+ * LDT - Lightweight (MP-)DCCP Tunnel kernel module
+ *
+ * This is not Open Source software.
+ * This work is made available to you under a source-available license, as
+ * detailed below.
+ *
+ * Copyright 2022 Deutsche Telekom AG
+ *
+ * Permission is hereby granted, free of charge, subject to below Commons
+ * Clause, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * “Commons Clause” License Condition v1.0
+ *
+ * The Software is provided to you by the Licensor under the License, as
+ * defined below, subject to the following condition.
+ *
+ * Without limiting other conditions in the License, the grant of rights under
+ * the License will not include, and the License does not grant to you, the
+ * right to Sell the Software.
+ *
+ * For purposes of the foregoing, “Sell” means practicing any or all of the
+ * rights granted to you under the License to provide to third parties, for a
+ * fee or other consideration (including without limitation fees for hosting
+ * or consulting/ support services related to the Software), a product or
+ * service whose value derives, entirely or substantially, from the
+ * functionality of the Software. Any license notice or attribution required
+ * by the License must also include this Commons Clause License Condition
+ * notice.
+ *
+ * Licensor: Deutsche Telekom AG
+ */
+
+#ifndef _R__KERNEL_LDT_IP_H
+#define _R__KERNEL_LDT_IP_H
+
+
+
+
+
+
+int ldt_msglen (char *buf, int len);
+int ldt_l4hdrlen (int prot, char *data, int sz);
+int ldt_iphdrlen (char *data, int sz, int *l4prot);
+int ldt_ipv4hdrlen (char *data, int sz, int *l4prot);
+int ldt_ipv6hdrlen (char *data, int sz, int *l4prot);
+
+
+
+
+
+
+
+
+
+
+
+
+
+#endif	/* _R__KERNEL_LDT_IP_H */
+
+
+/*
+ * Overrides for XEmacs and vim so that we get a uniform tabbing style.
+ * XEmacs/vim will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 3
+ * c-basic-offset: 3
+ * tab-width: 3
+ * End:
+ * vim:tw=0:ts=3:wm=0:
+ */
diff --git a/net/ldt/ldt_lock.c b/net/ldt/ldt_lock.c
new file mode 100644
index 0000000000000..3670cc0e6777a
--- /dev/null
+++ b/net/ldt/ldt_lock.c
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2015-2022 by Frank Reker, Deutsche Telekom AG
+ *
+ * LDT - Lightweight (MP-)DCCP Tunnel kernel module
+ *
+ * This is not Open Source software.
+ * This work is made available to you under a source-available license, as
+ * detailed below.
+ *
+ * Copyright 2022 Deutsche Telekom AG
+ *
+ * Permission is hereby granted, free of charge, subject to below Commons
+ * Clause, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * “Commons Clause” License Condition v1.0
+ *
+ * The Software is provided to you by the Licensor under the License, as
+ * defined below, subject to the following condition.
+ *
+ * Without limiting other conditions in the License, the grant of rights under
+ * the License will not include, and the License does not grant to you, the
+ * right to Sell the Software.
+ *
+ * For purposes of the foregoing, “Sell” means practicing any or all of the
+ * rights granted to you under the License to provide to third parties, for a
+ * fee or other consideration (including without limitation fees for hosting
+ * or consulting/ support services related to the Software), a product or
+ * service whose value derives, entirely or substantially, from the
+ * functionality of the Software. Any license notice or attribution required
+ * by the License must also include this Commons Clause License Condition
+ * notice.
+ *
+ * Licensor: Deutsche Telekom AG
+ */
+
+
+#include <linux/spinlock.h>
+
+#include "ldt_lock.h"
+
+
+
+
+void
+tp_lock_init (lock)
+	struct tp_lock	*lock;
+{
+	if (!lock) return;
+	*lock = (struct tp_lock) { .ltype = 0 };
+	spin_lock_init (&lock->lock);
+}
+
+void
+tp_lock_destroy (lock)
+	struct tp_lock	*lock;
+{
+	if (!lock) return;
+	*lock = (struct tp_lock) { .ltype = 0 };
+}
+
+
+void
+tp_lock (lock)
+	struct tp_lock	*lock;
+{
+	volatile unsigned long	flags;
+
+	if (!lock) return;
+	if (in_irq()) {
+		spin_lock_irqsave (&lock->lock, flags);
+		lock->irq_flags = flags;
+		lock->ltype = 1;
+	} else if (in_softirq()) {		/* not really needed */
+		spin_lock_bh (&lock->lock);
+		lock->ltype = 2;
+	} else {
+		spin_lock (&lock->lock);
+		lock->ltype = 3;
+	}
+}
+
+void
+tp_unlock (lock)
+	struct tp_lock	*lock;
+{
+	volatile unsigned long	flags;
+	int							ltype;
+
+	if (!lock) return;
+	ltype = lock->ltype;
+	lock->ltype = 0;
+	switch (ltype) {
+	case 1:
+		flags = lock->irq_flags;
+		spin_unlock_irqrestore (&lock->lock, flags);
+		break;
+	case 2:
+		spin_unlock_bh (&lock->lock);
+		break;
+	case 3:
+		spin_unlock (&lock->lock); \
+		break;
+	}
+}
+
+
+
+
+/*
+ * Overrides for XEmacs and vim so that we get a uniform tabbing style.
+ * XEmacs/vim will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 3
+ * c-basic-offset: 3
+ * tab-width: 3
+ * End:
+ * vim:tw=0:ts=3:wm=0:
+ */
diff --git a/net/ldt/ldt_lock.h b/net/ldt/ldt_lock.h
new file mode 100644
index 0000000000000..ebf4366691ba4
--- /dev/null
+++ b/net/ldt/ldt_lock.h
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2015-2022 by Frank Reker, Deutsche Telekom AG
+ *
+ * LDT - Lightweight (MP-)DCCP Tunnel kernel module
+ *
+ * This is not Open Source software.
+ * This work is made available to you under a source-available license, as
+ * detailed below.
+ *
+ * Copyright 2022 Deutsche Telekom AG
+ *
+ * Permission is hereby granted, free of charge, subject to below Commons
+ * Clause, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * “Commons Clause” License Condition v1.0
+ *
+ * The Software is provided to you by the Licensor under the License, as
+ * defined below, subject to the following condition.
+ *
+ * Without limiting other conditions in the License, the grant of rights under
+ * the License will not include, and the License does not grant to you, the
+ * right to Sell the Software.
+ *
+ * For purposes of the foregoing, “Sell” means practicing any or all of the
+ * rights granted to you under the License to provide to third parties, for a
+ * fee or other consideration (including without limitation fees for hosting
+ * or consulting/ support services related to the Software), a product or
+ * service whose value derives, entirely or substantially, from the
+ * functionality of the Software. Any license notice or attribution required
+ * by the License must also include this Commons Clause License Condition
+ * notice.
+ *
+ * Licensor: Deutsche Telekom AG
+ */
+
+#ifndef _R__LDT_LOCK_H
+#define _R__LDT_LOCK_H
+
+#include <linux/spinlock.h>
+
+
+struct tp_lock {
+	spinlock_t		lock;
+	unsigned long	irq_flags;
+	int				ltype;
+};
+
+void tp_lock_init (struct tp_lock*);
+void tp_lock_destroy (struct tp_lock*);
+void tp_lock (struct tp_lock*);
+void tp_unlock (struct tp_lock*);
+
+
+
+
+#endif	/* _R__LDT_LOCK_H */
+
+/*
+ * Overrides for XEmacs and vim so that we get a uniform tabbing style.
+ * XEmacs/vim will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 3
+ * c-basic-offset: 3
+ * tab-width: 3
+ * End:
+ * vim:tw=0:ts=3:wm=0:
+ */
diff --git a/net/ldt/ldt_mod.c b/net/ldt/ldt_mod.c
new file mode 100644
index 0000000000000..2909e8604ed59
--- /dev/null
+++ b/net/ldt/ldt_mod.c
@@ -0,0 +1,139 @@
+/*
+ * Copyright (C) 2015-2022 by Frank Reker, Deutsche Telekom AG
+ *
+ * LDT - Lightweight (MP-)DCCP Tunnel kernel module
+ *
+ * This is not Open Source software.
+ * This work is made available to you under a source-available license, as
+ * detailed below.
+ *
+ * Copyright 2022 Deutsche Telekom AG
+ *
+ * Permission is hereby granted, free of charge, subject to below Commons
+ * Clause, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * “Commons Clause” License Condition v1.0
+ *
+ * The Software is provided to you by the Licensor under the License, as
+ * defined below, subject to the following condition.
+ *
+ * Without limiting other conditions in the License, the grant of rights under
+ * the License will not include, and the License does not grant to you, the
+ * right to Sell the Software.
+ *
+ * For purposes of the foregoing, “Sell” means practicing any or all of the
+ * rights granted to you under the License to provide to third parties, for a
+ * fee or other consideration (including without limitation fees for hosting
+ * or consulting/ support services related to the Software), a product or
+ * service whose value derives, entirely or substantially, from the
+ * functionality of the Software. Any license notice or attribution required
+ * by the License must also include this Commons Clause License Condition
+ * notice.
+ *
+ * Licensor: Deutsche Telekom AG
+ */
+
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/genetlink.h>
+#include <linux/version.h>
+
+#include "ldt_netlink.h"
+#include "ldt_event.h"
+#include "ldt_sysctl.h"
+#include "ldt_dev.h"
+#include "ldt_version.h"
+#include "ldt_uapi.h"
+#if IS_ENABLED(CONFIG_IP_DCCP)
+# include "ldt_mpdccp.h"
+#endif
+#include "ldt_debug.h"
+
+
+static
+int
+__init
+ldt_module_init (void)
+{
+	int	ret;
+
+	tp_prtk ("load module version %s", LDT_VERSION);
+	ret = ldt_nl_register ();
+	if (ret < 0) return ret;
+	ret = ldt_sysctl_init ();
+	if (ret < 0) return ret;
+	ret = ldt_dev_global_init ();
+	if (ret < 0) return ret;
+#if IS_ENABLED(CONFIG_IP_DCCP)
+	ret = ldt_mpdccp_register ();
+	if (ret < 0) return ret;
+#endif
+	tp_prtk ("module version %s successfully loaded\n", LDT_VERSION);
+	return 0;
+}
+
+
+static
+void
+__exit
+ldt_module_exit (void)
+{
+	ldt_dev_global_destroy ();
+#if IS_ENABLED(CONFIG_IP_DCCP)
+	ldt_mpdccp_unregister ();
+#endif
+	ldt_event_crsend (LDT_EVTYPE_TPDOWN, NULL, 0);
+	ldt_sysctl_exit ();
+	ldt_nl_unregister ();
+	tp_prtk ("module ver %s unloaded\n", LDT_VERSION);
+}
+
+
+
+module_init (ldt_module_init);
+module_exit (ldt_module_exit);
+
+
+MODULE_LICENSE("Proprietary");
+MODULE_AUTHOR("Frank Reker <frank@reker.net>");
+MODULE_VERSION(LDT_VERSION);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+MODULE_ALIAS_GENL_FAMILY(LDT_NAME);
+#endif
+
+
+
+
+
+
+
+/*
+ * Overrides for XEmacs and vim so that we get a uniform tabbing style.
+ * XEmacs/vim will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 3
+ * c-basic-offset: 3
+ * tab-width: 3
+ * End:
+ * vim:tw=0:ts=3:wm=0:
+ */
diff --git a/net/ldt/ldt_mpdccp.c b/net/ldt/ldt_mpdccp.c
new file mode 100644
index 0000000000000..69f473b97503d
--- /dev/null
+++ b/net/ldt/ldt_mpdccp.c
@@ -0,0 +1,2001 @@
+/*
+ * Copyright (C) 2015-2022 by Frank Reker, Deutsche Telekom AG
+ *
+ * LDT - Lightweight (MP-)DCCP Tunnel kernel module
+ *
+ * This is not Open Source software.
+ * This work is made available to you under a source-available license, as
+ * detailed below.
+ *
+ * Copyright 2022 Deutsche Telekom AG
+ *
+ * Permission is hereby granted, free of charge, subject to below Commons
+ * Clause, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * “Commons Clause” License Condition v1.0
+ *
+ * The Software is provided to you by the Licensor under the License, as
+ * defined below, subject to the following condition.
+ *
+ * Without limiting other conditions in the License, the grant of rights under
+ * the License will not include, and the License does not grant to you, the
+ * right to Sell the Software.
+ *
+ * For purposes of the foregoing, “Sell” means practicing any or all of the
+ * rights granted to you under the License to provide to third parties, for a
+ * fee or other consideration (including without limitation fees for hosting
+ * or consulting/ support services related to the Software), a product or
+ * service whose value derives, entirely or substantially, from the
+ * functionality of the Software. Any license notice or attribution required
+ * by the License must also include this Commons Clause License Condition
+ * notice.
+ *
+ * Licensor: Deutsche Telekom AG
+ */
+
+
+#include <linux/socket.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/netlink.h>
+#include <net/sock.h>
+#include <net/tcp_states.h>
+#include <net/genetlink.h>
+#include <linux/skbuff.h>
+#include <linux/notifier.h>
+#include <linux/errno.h>
+#include <linux/in6.h>
+#include <linux/in.h>
+#include <linux/init.h>
+#include <linux/kthread.h>
+#include <linux/types.h>
+#include <linux/uaccess.h>
+#include <linux/netdevice.h>
+#include <linux/ip.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/etherdevice.h>
+#include <linux/crypto.h>
+#include <linux/err.h>
+#include <linux/scatterlist.h>
+#include <linux/udp.h>
+#include <linux/ipv6.h>
+#include <net/ipv6.h>
+#include <net/udp.h>
+#ifdef CONFIG_NET_UDP_TUNNEL
+# include <net/udp_tunnel.h>
+#endif
+//#include <net/ip_tunnels.h>
+#include <linux/version.h>
+#if IS_ENABLED(CONFIG_IP_MPDCCP)
+# include <net/mpdccp_link_info.h>
+# include <net/mpdccp.h>
+#endif
+#include <uapi/linux/dccp.h>
+
+#include "ldt_uapi.h"
+#include "ldt_dev.h"
+#include "ldt_tun.h"
+#include "ldt_debug.h"
+#include "ldt_event.h"
+#include "ldt_addr.h"
+#include "ldt_prot1.h"
+#include "ldt_ip.h"
+#include "ldt_tunaddr.h"
+#include "ldt_queue.h"
+#include "ldt_lock.h"
+
+
+#ifdef NET_IP_ALIGN
+# define TP_IPALIGN	NET_IP_ALIGN
+#else
+# define TP_IPALIGN	0
+#endif
+
+/* the following is a hack - to be removed later on! */
+#ifdef DCCP_SOCKOPT_KEEPALIVE
+# ifndef DCCPQ_POLICY_DROP_OLDEST
+#   define DCCPQ_POLICY_DROP_OLDEST DCCPQ_POLICY_DROP_OLDEST
+# endif
+# ifndef DCCPQ_POLICY_DROP_NEWEST
+#   define DCCPQ_POLICY_DROP_NEWEST DCCPQ_POLICY_DROP_NEWEST
+# endif
+#endif
+
+#define TP_IPHDRLEN		(sizeof (struct iphdr)   + TP_IPALIGN)
+#define TP_IP6HDRLEN		(sizeof (struct ipv6hdr) + TP_IPALIGN)
+
+
+#define TP_DCCHDRLEN		(255*sizeof(u32))
+#define TP_DCCPOPTLEN	(TP_DCCPHDRLLEN - sizeof(struct dccp_hdr))
+#define TP_PROTLEN		(0)
+#define TP_BHDRLEN		(TP_DCCHDRLEN + TP_PROTLEN)
+#define TP_HDRLEN		(TP_IPHDRLEN  + TP_BHDRLEN)
+#define TP_HDR6LEN	(TP_IP6HDRLEN + TP_BHDRLEN)
+#define TP_MINHEADROOM	(TP_HDRLEN  + NET_SKB_PAD)
+#define TP_MIN6HEADROOM	(TP_HDR6LEN + NET_SKB_PAD)
+
+struct mpdccptun;
+static int mpdccptun_new (struct ldt_tun*, const char *);
+static int mpdccptun_bind (struct mpdccptun*, tp_addr_t*, int);
+static int mpdccptun_dobind (struct mpdccptun*);
+static int mpdccptun_peer (struct mpdccptun*, tp_addr_t*);
+static void mpdccptun_remove (struct mpdccptun*);
+static netdev_tx_t ldt_mpdccptun_xmit (struct mpdccptun*, struct sk_buff*);
+static int mpdccptun_elab_xmit2 (struct mpdccptun*, struct sk_buff*);
+static int mpdccptun_elab_xmit (struct mpdccptun*);
+static int mpdccptun_xmit (struct mpdccptun*, char*, int, tp_addr_t*);
+static int mpdccptun_prepare_skb (struct mpdccptun*, struct sk_buff*, int*);
+static int mpdccptun_check_enqueue (struct mpdccptun*, struct sk_buff*);
+static int mpdccptun_do_enqueue (struct mpdccptun*, struct sk_buff*);
+static ssize_t mpdccptun_getinfo (struct mpdccptun*, char*, size_t);
+static int mpdccptun_eventcreate (struct mpdccptun*, char*, size_t, const char*, const char*);
+static int mpdccptun_elab_recv (struct mpdccptun*, struct sk_buff*);
+static void mpdccptun_scrub_skb (struct sk_buff*);
+#if IS_ENABLED(CONFIG_IP_MPDCCP)
+static void tp_subflow_report (int, struct sock*, struct sock*, struct mpdccp_link_info*, int);
+static int tp_subflow_reg (struct sock*);
+static int tp_subflow_dereg (struct sock*);
+#endif
+static int mpdccptun_serverstart (struct mpdccptun*);
+static int mpdccptun_doserverstart (struct mpdccptun*);
+static int mpdccptun_setqueue (struct mpdccptun*, int, int);
+static void _myclose (struct socket*);
+static int mpdccptun_elab_accept (struct mpdccptun*);
+static void accept_handler (struct work_struct*);
+static void listen_handler (struct work_struct*);
+static void xmit_handler (struct work_struct*);
+static void xmit_handler_delayed (struct work_struct*);
+static void do_xmit_handler (struct mpdccptun*);
+static int mpdccptun_elab_connect (struct mpdccptun*);
+static void connect_handler (struct work_struct*);
+#if IS_ENABLED(CONFIG_IP_MPDCCP)
+static int mpdccptun_linkdown (struct mpdccptun*);
+#endif
+static void conn_timer_handler (struct timer_list *t);
+
+static int do_xmit_skb (struct mpdccptun *, struct sk_buff*);
+static int mpdccptun_needheadroom (struct mpdccptun*);
+static int mpdccptun_getmtu (void*);
+static void mpdccptun_closesk (struct mpdccptun*);
+static void mpdccptun_close_listen (struct mpdccptun*);
+
+
+struct ldt_tunops	mpdccptun_ops = {
+	.tp_new = mpdccptun_new,
+	.tp_bind = (void*)mpdccptun_bind,
+	.tp_peer = (void*)mpdccptun_peer,
+	.tp_serverstart = (void*)mpdccptun_serverstart,
+	.tp_remove = (void*)mpdccptun_remove,
+	.tp_xmit = (void*)ldt_mpdccptun_xmit,
+	.tp_gettuninfo = (void*)mpdccptun_getinfo,
+	.tp_createvent = (void*)mpdccptun_eventcreate,
+	.tp_prot1xmit = (void*)mpdccptun_xmit,
+	.tp_needheadroom = (void*)mpdccptun_needheadroom,
+	.tp_getmtu = mpdccptun_getmtu,
+	.tp_setqueue = (void*)mpdccptun_setqueue,
+	.ipv6 = 0,
+};
+
+struct ldt_tunops	mpdccptun_ops6 = {
+	.tp_new = mpdccptun_new,
+	.tp_bind = (void*)mpdccptun_bind,
+	.tp_peer = (void*)mpdccptun_peer,
+	.tp_serverstart = (void*)mpdccptun_serverstart,
+	.tp_remove = (void*)mpdccptun_remove,
+	.tp_xmit = (void*)ldt_mpdccptun_xmit,
+	.tp_gettuninfo = (void*)mpdccptun_getinfo,
+	.tp_createvent = (void*)mpdccptun_eventcreate,
+	.tp_prot1xmit = (void*)mpdccptun_xmit,
+	.tp_needheadroom = (void*)mpdccptun_needheadroom,
+	.tp_getmtu = mpdccptun_getmtu,
+	.tp_setqueue = (void*)mpdccptun_setqueue,
+	.ipv6 = 1,
+};
+
+
+#define MPDCCPTUN_MAGIC	(0xcaee6c49)
+#define ISMPDCCPTUN(tdat) ((tdat) && (tdat)->MAGIC == MPDCCPTUN_MAGIC)
+
+
+typedef struct { char s[IFNAMSIZ+1]; } subflow_str;
+
+struct mpdccptun {
+	u32							MAGIC;
+	struct ldt_tun		*tun;
+	struct net_device			*ndev;
+	const char					*name;
+	u32							tostop;
+	u32							ipv6:1,
+									ismpdccp:1,
+									bound:1,
+									rebind:1,
+									haspeer:1,
+									noauthqueue:1,
+									listening:1,
+									isserver:1,
+									isconnected:1,
+									wasconnected:1,
+									has_delayed_work:1,
+									has_subflow_report:1;
+	u16							tx_qlen;
+	u16							qpolicy;
+	unsigned long				last_unconnect;
+	subflow_str					*subflow;
+	int							num_subflow;
+	int							bufsz_subflow;
+	subflow_str					subflow_report;
+	tp_tunaddr_t				addr;
+	struct socket				*sock;
+	struct socket				*active;
+	struct work_struct		work_conn;
+	struct work_struct		work_listen;
+	struct work_struct		work_accept;
+	struct work_struct		work_xmit;
+	struct delayed_work		work_xmit_delayed;
+	struct tp_queue			xmit_queue;
+	struct timer_list			conn_timer;
+	struct tp_lock				lock;
+	struct tp_lock				lock2;
+};
+
+
+
+static int mpdccptun_xmit_skb (struct mpdccptun*, struct sk_buff*);
+static int mpdccptun_dorcv_all (struct mpdccptun*, struct sock*);
+static int mpdccptun_dorcv (struct mpdccptun*, struct sock*);
+static int mpdccptun_dorcv2 (struct mpdccptun*, struct sock*);
+static int rcv_prepare_skb (struct sk_buff**, struct sk_buff*);
+static int dorcv_datagram (struct sk_buff**, struct sock*, int);
+static int mpdccptun_needrcvcpy (struct sk_buff*);
+static void tp_elab_data_ready (struct sock *);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0)
+static void tp_cli_data_ready (struct sock *, int);
+static void tp_srv_data_ready (struct sock *, int);
+static void tp_listen_ready (struct sock *, int);
+#else
+static void tp_cli_data_ready (struct sock *);
+static void tp_srv_data_ready (struct sock *);
+static void tp_listen_ready (struct sock *);
+#endif
+static void tp_set_tdat (struct socket*, struct mpdccptun*);
+static void tp_unset_tdat (struct socket*);
+#if IS_ENABLED(CONFIG_IP_MPDCCP)
+static int tp_subflow_global_reg (void);
+static int tp_subflow_global_dereg (void);
+#endif
+
+
+
+#define ISSTOP(tdat) (smp_load_acquire(&(tdat->tostop)))
+#define CHKSTOP(ret) { if (ISSTOP(tdat)) { return (ret); } }
+#define CHKSTOPVOID	{ if (ISSTOP(tdat)) { return; } }
+#ifdef DOUSELOCK
+#define DOLOCK(tdat) do { tp_lock (&(tdat)->lock); } while (0)
+#define DOUNLOCK(tdat) do { tp_unlock (&(tdat)->lock); } while (0)
+#else
+#define DOLOCK(tdat) do {} while (0)
+#define DOUNLOCK(tdat) do {} while (0)
+#endif
+#define DOLOCK2(tdat) do { tp_lock (&(tdat)->lock2); } while (0)
+#define DOUNLOCK2(tdat) do { tp_unlock (&(tdat)->lock2); } while (0)
+#define MYCLOSE(tdat,var)	do { \
+	struct socket	*_sock; \
+	DOLOCK(tdat); \
+	_sock = (tdat)->var; \
+	(tdat)->var = NULL; \
+	DOUNLOCK(tdat); \
+	_myclose (_sock); \
+} while (0)
+
+static int mpdccptun_getmtu (void *t)
+{
+	return 0;
+}
+static int mpdccptun_needheadroom (tdat)
+	struct mpdccptun	*tdat;
+{
+	if (!tdat) return TP_MINHEADROOM > TP_MIN6HEADROOM ? TP_MINHEADROOM : TP_MIN6HEADROOM;
+	if (tdat->ipv6) return TP_MIN6HEADROOM;
+	return TP_MINHEADROOM;
+}
+
+int
+ldt_mpdccp_register (void)
+{
+	int	ret;
+
+#if IS_ENABLED(CONFIG_IP_MPDCCP)
+	ret = ldt_tun_register ("mpdccp", &mpdccptun_ops);
+	if (ret < 0) return ret;
+	ret = ldt_tun_register ("mpdccp4", &mpdccptun_ops);
+	if (ret < 0) return ret;
+	ret = ldt_tun_register ("mpdccp6", &mpdccptun_ops6);
+	if (ret < 0) return ret;
+#endif
+	ret = ldt_tun_register ("dccp", &mpdccptun_ops);
+	if (ret < 0) return ret;
+	ret = ldt_tun_register ("dccp4", &mpdccptun_ops);
+	if (ret < 0) return ret;
+	ret = ldt_tun_register ("dccp6", &mpdccptun_ops6);
+	if (ret < 0) return ret;
+#if IS_ENABLED(CONFIG_IP_MPDCCP)
+	ret = tp_subflow_global_reg ();
+	if (ret < 0) return ret;
+#endif
+	return 0;
+}
+
+//static
+void
+//__exit
+ldt_mpdccp_unregister (void)
+{
+#if IS_ENABLED(CONFIG_IP_MPDCCP)
+	tp_subflow_global_dereg ();
+	ldt_tun_unregister ("mpdccp");
+	ldt_tun_unregister ("mpdccp4");
+	ldt_tun_unregister ("mpdccp6");
+#endif
+	ldt_tun_unregister ("dccp");
+	ldt_tun_unregister ("dccp4");
+	ldt_tun_unregister ("dccp6");
+}
+
+static
+int
+mpdccptun_new (tun, type)
+	struct ldt_tun	*tun;
+	const char				*type;
+{
+	int					ipv6, ismp=1;
+	struct mpdccptun	*tdat;
+
+	if (!tun || !tun->tdev || !tun->tdev->ndev || !type) return -EINVAL;
+#if IS_ENABLED(CONFIG_IP_MPDCCP)
+	if (!strcasecmp (type, "mpdccp6")) {
+		ipv6 = 1;
+	} else if (!strcasecmp (type, "mpdccp4") || !strcasecmp (type, "mpdccp")) {
+		ipv6 = 0;
+	} else
+#endif
+	if (!strcasecmp (type, "dccp6")) {
+		ipv6 = 1;
+		ismp = 0;
+	} else if (!strcasecmp (type, "dccp4") || !strcasecmp (type, "dccp")) {
+		ipv6 = 0;
+		ismp = 0;
+	} else {
+		return -ENOTSUPP;
+	}
+	tp_info ("create %s tunnel\n", type);
+	tdat = kmalloc (sizeof (struct mpdccptun), GFP_KERNEL);
+	if (!tdat) return -ENOMEM;
+	*tdat = (struct mpdccptun) {
+			.MAGIC = MPDCCPTUN_MAGIC,
+			.tun = tun,
+			.ndev = tun->tdev->ndev,
+			.name = tun->tdev->ndev->name,
+			.ipv6 = ipv6,
+			.ismpdccp = ismp,
+			.tx_qlen = 1000,
+#if defined DCCPQ_POLICY_DROP_NEWEST
+			.qpolicy = DCCPQ_POLICY_DROP_NEWEST,
+#else
+			.qpolicy = DCCPQ_POLICY_SIMPLE,
+#endif
+	};
+	ldt_tunaddr_init (&tdat->addr, ipv6);
+	tun->tundata = tdat;
+	tun->tunops = ipv6 ? &mpdccptun_ops6 : &mpdccptun_ops;
+	INIT_WORK (&tdat->work_accept, accept_handler);
+	INIT_WORK (&tdat->work_listen, listen_handler);
+	INIT_WORK (&tdat->work_conn, connect_handler);
+	INIT_WORK (&tdat->work_xmit, xmit_handler);
+	INIT_DELAYED_WORK (&tdat->work_xmit_delayed, xmit_handler_delayed);
+	tpq_init (&tdat->xmit_queue, TP_QUEUE_DROP_NEWEST, 1000);
+	tp_lock_init (&tdat->lock);
+	tp_lock_init (&tdat->lock2);
+	timer_setup(&tdat->conn_timer, conn_timer_handler, 0);
+	// setup_timer(&tdat->conn_timer, conn_timer_handler, (unsigned long)tdat);
+	tp_debug3 ("tdat=%p, tun=%p\n", tdat, tdat->tun);
+	return 0;
+}
+
+
+static
+int
+mpdccptun_bind (tdat, addr, flags)
+	struct mpdccptun	*tdat;
+	tp_addr_t			*addr;
+	int					flags;
+{
+	int	ret;
+
+	if (!tdat) return -EINVAL;
+	if (!addr) return 0;
+	if (ISSTOP(tdat)) return 0;
+	ret = ldt_tunaddr_bind (&tdat->addr, addr, flags);
+	if (ret < 0) {
+		tp_err ("error copying address: %d\n", ret);
+		return ret;
+	}
+	//tdat->bind_flags = flags;
+	if (tdat->bound) tdat->rebind = 1;
+	if (!tdat->isserver && tdat->isconnected) {
+		ret = queue_work (system_wq, &tdat->work_conn);
+		if (ret < 0) {
+			tp_err ("error queuing work: %d\n", ret);
+			return ret;
+		}
+	} else if (tdat->isserver && tdat->listening) {
+		ret = queue_work (system_wq, &tdat->work_listen);
+		if (ret < 0) {
+			tp_err ("error queuing work: %d\n", ret);
+			return ret;
+		}
+	}
+	tp_debug ("new address set");
+	return 0;
+}
+
+static
+void
+mpdccptun_close_listen (tdat)
+	struct mpdccptun	*tdat;
+{
+	struct socket	*_active = NULL;
+	struct socket	*_pending = NULL;
+	struct socket	*_sock = NULL;
+
+	if (!tdat) return;
+	tp_debug3 ("release old socket");
+	DOLOCK (tdat);
+	if (tdat->active) {
+		tp_unset_tdat (tdat->active);
+		_active = tdat->active;
+		tdat->active = NULL;
+	}
+	_sock = tdat->sock;
+	tdat->listening = 0;
+	tdat->isconnected = 0;
+	DOUNLOCK (tdat);
+	if (_pending) {
+		tp_debug3 ("close pending socket");
+		_myclose (_pending);
+	}
+	if (_active) {
+		tp_debug3 ("close active socket");
+		_myclose (_active);
+	}
+	if (_sock) {
+		tp_debug3 ("shutdown listen socket");
+		kernel_sock_shutdown(tdat->sock, SHUT_RDWR);
+	}
+}
+
+static
+void
+mpdccptun_closesk (tdat)
+	struct mpdccptun	*tdat;
+{
+	struct socket	*_active = NULL;
+	struct socket	*_sock = NULL;
+
+	if (!tdat) return;
+	tp_debug3 ("release old socket");
+	DOLOCK (tdat);
+	if (tdat->active) {
+		tp_unset_tdat (tdat->active);
+		_active = tdat->active;
+		tdat->active = NULL;
+	}
+	if (tdat->sock) {
+		tp_unset_tdat (tdat->sock);
+		_sock = tdat->sock;
+		tdat->sock = NULL;
+	}
+	tdat->bound = 0;
+	tdat->rebind = 0;
+	tdat->listening = 0;
+	tdat->isconnected = 0;
+	DOUNLOCK (tdat);
+	if (_active) {
+		tp_debug3 ("close active socket");
+		_myclose (_active);
+	}
+	if (_sock) {
+		tp_debug3 ("close listen/client socket");
+		_myclose (_sock);
+	}
+}
+
+static
+int
+mpdccptun_dobind (tdat)
+	struct mpdccptun	*tdat;
+{
+	int			ret;
+	int			val;
+	sockptr_t val2;
+
+	tp_debug3 ("enter");
+	if (!tdat) return -EINVAL;
+	if (ISSTOP(tdat)) return 0;
+	if ((!tdat->addr.bound || tdat->addr.anylport) && tdat->isserver) {
+		tp_err ("server cannot bind to anyport\n");
+		return -ENOTCONN;
+	}
+	if (tdat->bound) {
+		if (!tdat->rebind) return 0;
+		mpdccptun_closesk (tdat);
+	}
+
+	tp_debug3 ("create socket");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,2,0)
+	ret = sock_create_kern (TP_ADDR_FAM(tdat->addr.laddr), SOCK_DCCP,
+									IPPROTO_DCCP, &tdat->sock);
+	// Todo: setting network namespace manually
+#else
+	ret = sock_create_kern (NDEV2NET(tdat->ndev), TP_ADDR_FAM(tdat->addr.laddr),
+									SOCK_DCCP, IPPROTO_DCCP, &tdat->sock);
+#endif
+	if (ret < 0) {
+		tp_err ("error creating socket: %d", ret);
+		return ret;
+	}
+
+	if (tp_addr_getport (&tdat->addr.laddr) > 0) {
+		val = 1;
+		val2 = KERNEL_SOCKPTR((char*)&val);
+		ret = tdat->sock->ops->setsockopt(tdat->sock, SOL_SOCKET, SO_REUSEADDR,
+              	val2, sizeof(val2));
+		if (ret < 0) {
+			tp_warn ("warn: error setting reuseaddr: %d", ret);
+		}
+	}
+
+#if IS_ENABLED(CONFIG_IP_MPDCCP)
+	if (tdat->ismpdccp) {
+		tp_debug2 ("switch to multipath");
+		val = 1;
+		val2 = KERNEL_SOCKPTR((char*)&val);
+		ret = tdat->sock->ops->setsockopt(tdat->sock, SOL_DCCP, DCCP_SOCKOPT_MULTIPATH,
+              	val2, sizeof(val2));
+		if (ret < 0) {
+			tp_err ("error switching to multipath: %d", ret);
+			goto dorelease;
+		}
+	}
+#endif
+#if defined DCCP_SOCKOPT_QPOLICY_TXQLEN
+	tpq_set_maxlen (&tdat->xmit_queue, tdat->tx_qlen);
+	val = tdat->tx_qlen;
+	val2 = KERNEL_SOCKPTR((char*)&val);
+	ret = tdat->sock->ops->setsockopt(tdat->sock, SOL_DCCP, DCCP_SOCKOPT_QPOLICY_TXQLEN,
+              val2, sizeof(val2));
+	if (ret < 0) {
+		tp_err ("error setting tx qlen: %d\n", ret);
+		goto dorelease;
+	}
+#endif
+#if defined DCCP_SOCKOPT_QPOLICY_ID
+	val = tdat->qpolicy;
+	val2 = KERNEL_SOCKPTR((char*)&val);
+	ret = tdat->sock->ops->setsockopt(tdat->sock, SOL_DCCP, DCCP_SOCKOPT_QPOLICY_ID,
+              val2, sizeof(val2));
+	if (ret < 0) {
+		tp_err ("error setting qpolicy: %d\n", ret);
+		goto dorelease;
+	}
+#endif
+	tp_debug3 ("bind socket to address");
+	ret = kernel_bind (	tdat->sock, &tdat->addr.laddr.ad,
+								TP_ADDR_SIZE (tdat->addr.laddr));
+	if (ret < 0) {
+		tp_err ("error binding socket: %d\n", ret);
+dorelease:
+		MYCLOSE(tdat, sock);
+		return ret;
+	}
+	tp_set_tdat (tdat->sock, tdat);
+	tdat->bound = 1;
+
+	tp_debug3 ("done");
+
+	return 0;
+}
+
+static
+int
+mpdccptun_peer (tdat, addr)
+	struct mpdccptun	*tdat;
+	tp_addr_t			*addr;
+{
+	int	ret;
+
+	if (!tdat) return -EINVAL;
+	CHKSTOP(-EPERM);
+	if (addr) {
+		ret = ldt_tunaddr_setpeer (&tdat->addr, addr, 0);
+		if (ret < 0) {
+			return ret;
+		}
+		tdat->haspeer = 1;
+	}
+	if (!tdat->haspeer) {
+		tp_err ("no peer address");
+		return -ENOTCONN;
+	}
+	if (tdat->isserver) {
+		tp_debug ("we are server - don't do anything\n");
+		return 0;
+	}
+	ret = queue_work (system_wq, &tdat->work_conn);
+	return 0;
+}
+
+
+static
+void
+connect_handler(work)
+	struct work_struct	*work;
+{
+	struct mpdccptun	*tdat;
+	int					ret;
+
+	if (!work) return;
+	tdat = container_of (work, struct mpdccptun, work_conn);
+	tp_debug3 ("tdat=%p, tun=%p\n", tdat, tdat->tun);
+	ret = mpdccptun_elab_connect (tdat);
+	if (ret < 0) {
+		tp_err ("error connecting to peer: %d\n", ret);
+		ldt_event_crsend (LDT_EVTYPE_CONN_ESTAB_FAIL, tdat->tun, (-1)*ret);
+		return;
+	}
+	tp_debug2 ("new connection established\n");
+	ldt_event_crsend (LDT_EVTYPE_CONN_ESTAB, tdat->tun, 0);
+	return;
+}
+
+static
+int
+mpdccptun_elab_connect (tdat)
+	struct mpdccptun	*tdat;
+{
+	int	ret;
+
+	if (!tdat) return -EINVAL;
+	if (timer_pending (&tdat->conn_timer)) {
+		del_timer (&tdat->conn_timer);
+		// setup_timer(&tdat->conn_timer, conn_timer_handler, (unsigned long)tdat);
+		timer_setup(&tdat->conn_timer, conn_timer_handler, 0);
+	}
+	ret = mpdccptun_dobind (tdat);
+	if (ret < 0) {
+		tp_err ("error binding socket: %d\n", ret);
+		return ret;
+	}
+	CHKSTOP(-EPERM);
+	if (!tdat->haspeer) return -ENOTCONN;
+	tdat->sock->sk->sk_data_ready = tp_cli_data_ready;
+	ret = kernel_connect (tdat->sock, &tdat->addr.raddr.ad, TP_ADDR_SIZE(tdat->addr.raddr), 0);
+	if (ret < 0) {
+		tp_err ("error in connect: %d\n", ret);
+		return ret;
+	}
+	tdat->isconnected = 1;
+	tdat->wasconnected = 1;
+	if (tdat->ismpdccp) {
+		mod_timer(&tdat->conn_timer, jiffies + 5*HZ);	/* 5 secs */
+	}
+	return 0;
+}
+
+
+static
+void
+conn_timer_handler (struct timer_list *t)
+{
+	struct mpdccptun	*tdat = from_timer(tdat, t, conn_timer);
+	if (!tdat) return;
+	if (!tdat->ismpdccp) return;
+	if (tdat->num_subflow > 0) return;
+#if IS_ENABLED(CONFIG_IP_MPDCCP)
+	mpdccptun_linkdown (tdat);
+#endif
+}
+
+static
+int
+mpdccptun_serverstart (tdat)
+	struct mpdccptun	*tdat;
+{
+	if (!tdat) return -EINVAL;
+	if (tdat->isconnected) {
+		tp_err ("we are already client, cannot become server");
+		return -ENOTCONN;
+	}
+	if (tdat->isserver) return 0;
+	tdat->isserver = 1;
+	queue_work (system_wq, &tdat->work_listen);
+	return 0;
+}
+
+
+static
+void
+listen_handler(work)
+	struct work_struct	*work;
+{
+	struct mpdccptun	*tdat;
+	int					ret;
+
+	tdat = container_of (work, struct mpdccptun, work_listen);
+	ret = mpdccptun_doserverstart (tdat);
+	if (ret < 0) {
+		tp_err ("error listening: %d\n", ret);
+		ldt_event_crsend (LDT_EVTYPE_CONN_LISTEN_FAIL, tdat->tun, 0);
+		return;
+	}
+	tp_debug2 ("server is listening\n");
+	ldt_event_crsend (LDT_EVTYPE_CONN_LISTEN, tdat->tun, 0);
+	return;
+}
+
+
+static
+int
+mpdccptun_doserverstart (tdat)
+	struct mpdccptun	*tdat;
+{
+	int	ret;
+
+	if (!tdat) return -EINVAL;
+	if (!tdat->isserver) return -ENOTCONN;
+	ret = mpdccptun_dobind (tdat);
+	if (ret < 0) {
+		tp_err ("error binding socket: %d\n", ret);
+		return ret;
+	}
+	if (!tdat->sock || !tdat->sock->sk) return -ENOTCONN;
+	if (tdat->listening) {
+		mpdccptun_close_listen (tdat);
+	}
+	tp_debug ("set socket to listen mode\n");
+	CHKSTOP(-EPERM);
+	tdat->sock->sk->sk_data_ready = tp_listen_ready;
+	ret = kernel_listen (tdat->sock, 20);
+	if (ret < 0)
+		tp_err ("error in listen: %d\n", ret);
+	tdat->listening = 1;
+	return ret;
+}
+
+static
+int
+mpdccptun_setqueue (tdat, txqlen, qpolicy)
+	struct mpdccptun	*tdat;
+	int					txqlen, qpolicy;
+{
+	int				ret = 0;
+	int				val;
+	sockptr_t val2;
+	if (!tdat) return -EINVAL;
+	//if (!tdat->sock || !tdat->sock->sk) return -EPERM;
+	tp_debug ("set queue txqlen=%d, qpolicy=%d\n", txqlen, qpolicy);
+	CHKSTOP(-EPERM);
+	if (txqlen >= 0) {
+		tdat->tx_qlen = txqlen;
+	}
+	if (qpolicy >= 0) {
+		switch (qpolicy) {
+		case LDT_CMD_SETQUEUE_QPOLICY_DROP_OLDEST:
+#ifdef DCCPQ_POLICY_DROP_OLDEST
+			tdat->qpolicy = DCCPQ_POLICY_DROP_OLDEST;
+#endif
+			tpq_set_policy (&tdat->xmit_queue, TP_QUEUE_DROP_OLDEST);
+			break;
+		case LDT_CMD_SETQUEUE_QPOLICY_DROP_NEWEST:
+#ifdef DCCPQ_POLICY_DROP_NEWEST
+			tdat->qpolicy = DCCPQ_POLICY_DROP_NEWEST;
+#endif
+			tpq_set_policy (&tdat->xmit_queue, TP_QUEUE_DROP_NEWEST);
+			break;
+		default:
+			tp_warn ("unsupported queuing policy %d\n", qpolicy);
+			goto dorelease;
+		}
+	}
+	if (tdat->bound) {
+#ifdef DCCP_SOCKOPT_QPOLICY_TXQLEN
+		if (txqlen >= 0) {
+			tpq_set_maxlen (&tdat->xmit_queue, txqlen);
+			//val2.kernel = &txqlen;
+			val2 = KERNEL_SOCKPTR((char*)&txqlen);
+			ret = tdat->sock->ops->setsockopt(tdat->sock, SOL_DCCP, DCCP_SOCKOPT_QPOLICY_TXQLEN,
+              		val2, sizeof(val2));
+			if (ret < 0) {
+				tp_err ("error setting tx qlen: %d\n", ret);
+				goto dorelease;
+			}
+		}
+#endif
+#ifdef DCCP_SOCKOPT_QPOLICY_ID
+		if (qpolicy >= 0) {
+			val = tdat->qpolicy;
+			val2 = KERNEL_SOCKPTR((char*)&val);
+			ret = tdat->sock->ops->setsockopt(tdat->sock, SOL_DCCP, DCCP_SOCKOPT_QPOLICY_ID,
+              		val2, sizeof(val2));
+			if (ret < 0) {
+				tp_err ("error setting qpolicy: %d\n", ret);
+				goto dorelease;
+			}
+		}
+#endif
+	}
+
+dorelease:
+	if (ret < 0)
+		tp_err ("error set txqlen: %d\n", ret);
+	return ret;
+}
+
+
+static
+void
+mpdccptun_remove (tdat)
+	struct mpdccptun	*tdat;
+{
+	if (!tdat) return;
+	if (ISSTOP(tdat)) return;
+	smp_store_release (&(tdat->tostop), 1);
+
+	/* first make tunnel unavailable */
+	if (tdat->tun) {
+		tdat->tun->tundata = NULL;
+		tdat->tun->tunops = NULL;
+	}
+
+#if 0
+	/* cancel all pending work */
+	cancel_work(&tdat->work_conn);
+	cancel_work(&tdat->work_listen);
+	cancel_work(&tdat->work_accept);
+	cancel_work(&tdat->work_xmit);
+	cancel_delayed_work(&tdat->work_xmit_delayed);
+#endif
+
+	/* may close sockets */
+	if (tdat->bound) {
+		mpdccptun_closesk (tdat);
+	}
+
+	/* delete other data */
+
+	tp_debug2 ("destroy (work)queues and timers\n");
+	tpq_destroy (&tdat->xmit_queue);
+	del_timer (&tdat->conn_timer);
+
+	/* poison struct */
+	*tdat = (struct mpdccptun) { .MAGIC = 0, .tostop = 1, };
+	/* free struct */
+	kfree (tdat);
+	tp_debug3 ("done");
+}
+
+
+
+
+static
+int
+mpdccptun_eventcreate (tdat, evbuf, evlen, evtype, desc)
+	struct mpdccptun	*tdat;
+	char					*evbuf;
+	size_t				evlen;
+	const char			*evtype, *desc;
+{
+	int	ret;
+
+	if (!tdat) return -EINVAL;
+	if (!evtype) return -EINVAL;
+	CHKSTOP(-EPERM);
+	if (!desc) desc = "";
+	if (!evbuf) evlen = 0;
+	if (evlen > 0) evlen--;
+	if (tdat->has_subflow_report) {
+		ret = snprintf (evbuf, evlen, "<event type=\"%s\">\n"
+						"  <desc>%s</desc>\n"
+						"  <iface>%s</iface>\n"
+						"  <subflow>%s</subflow>\n"
+						"</event>\n", evtype, desc, tdat->name,
+						tdat->subflow_report.s);
+	} else {
+		ret = snprintf (evbuf, evlen, "<event type=\"%s\">\n"
+						"  <desc>%s</desc>\n"
+						"  <iface>%s</iface>\n"
+						"</event>\n", evtype, desc, tdat->name);
+	}
+	if (evbuf) evbuf[evlen]=0;
+	return ret;
+}
+
+
+
+static
+ssize_t
+mpdccptun_getinfo (tdat, info, ilen)
+	struct mpdccptun	*tdat;
+	char				*info;
+	size_t			ilen;
+{
+	int	len=0;
+	//char	buf[sizeof("xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:255.255.255.255")+2];
+	//int	i;
+
+	if (!tdat) return -EINVAL;
+//#define MYPRTIP(ad) (tp_addr_sprt_ip (buf, sizeof (buf), &(ad)) > 0 ? buf : "")
+#define _FSTR	(info ? info + len : NULL)
+#define _FLEN	(ilen > len ? ilen - len : 0)
+	CHKSTOP(-EPERM);
+	len += snprintf (_FSTR, _FLEN, "    <type>%sdccp%c</type>\n",
+							tdat->ismpdccp ? "mp" : "", tdat->ipv6 ? '6' : '4');
+	len += ldt_tunaddr_prt (&tdat->addr, _FSTR, _FLEN, 4);
+	len += snprintf (_FSTR, _FLEN, "    <status>%s,%s,tunup,ifup</status>\n",
+								(tdat->num_subflow > 0 ? "up" : "down"),
+								(tdat->tun->pdevdown ? "pdevdown" : "pdevup"));
+	len += snprintf (_FSTR, _FLEN, "    <subflowlist>\n");
+#if 0		/* to be fixed: locking can create dead lock with mutex in ldt_dev.c */
+	DOLOCK2(tdat);
+	for (i=0; i<tdat->num_subflow; i++) {
+		len += snprintf (_FSTR, _FLEN, "      <subflow>%s</subflow>\n", tdat->subflow[i].s);
+	}
+	DOUNLOCK2(tdat);
+#endif
+	len += snprintf (_FSTR, _FLEN, "    </subflowlist>\n");
+	return len;
+#undef _FSTR
+#undef _FLEN
+//#undef MYPRTIP
+}
+
+
+
+
+static
+netdev_tx_t
+ldt_mpdccptun_xmit (tdat, skb)
+	struct mpdccptun	*tdat;
+	struct sk_buff		*skb;
+{
+	int	ret;
+
+	ret = mpdccptun_do_enqueue (tdat, skb);
+	if (ret == -EAGAIN) {
+		/* here we should disable the xmit mech, but assume that it is
+		 * only for short */
+		tp_debug3 ("we are busy");
+		return NETDEV_TX_BUSY;
+	} else if (ret < 0) {
+		tp_debug2 ("error enqueuing (%d)", ret);
+	}
+	return NETDEV_TX_OK;
+}
+
+static
+int
+mpdccptun_do_enqueue (tdat, skb)
+	struct mpdccptun	*tdat;
+	struct sk_buff		*skb;
+{
+	struct sk_buff		*skb2;
+	int					ret, expired;
+
+	if (!tdat || !skb) {
+		/* drop */
+		if (skb) kfree_skb(skb);
+		return -EINVAL;
+	}
+
+	ret = mpdccptun_check_enqueue (tdat, skb);
+	if (ret < 0) {
+		tp_debug2 ("drop packets (reason=%d)\n", ret);
+		if (ret != -EAGAIN) {
+			kfree_skb (skb);
+		}
+		return ret;
+	}
+
+	/* extend header */
+	if (likely(skb_headroom(skb) < (tdat->ipv6 ? TP_HDR6LEN : TP_HDRLEN))) {
+		/* note that we extend more than what we need and check for -
+		 * for usage by underlying devices
+		 */
+		skb2 = skb;
+		skb = skb_realloc_headroom(skb2, mpdccptun_needheadroom (tdat));
+		if (!skb) {
+			kfree_skb (skb2);
+			return -ENOMEM;
+		} else if (skb != skb2) {
+			consume_skb (skb2);
+		}
+	}
+	ret = mpdccptun_prepare_skb (tdat, skb, &expired);
+	if (ret < 0) {
+		kfree_skb (skb);
+		if (ret == -EAGAIN) ret = -EINVAL;	/* should not happen */
+		return ret;
+	} else if (expired) {
+		tp_debug2 ("ttl expired - drop packet\n");
+		kfree_skb (skb);
+		return 0;
+	}
+
+	/* enqueue skb */
+	tpq_enqueue (&tdat->xmit_queue, skb);
+
+	/* do not schedule if we have delayed work */
+	if (!tdat->has_delayed_work) {
+		/* does not matter if it's already on the queue */
+		queue_work (system_wq, &tdat->work_xmit);
+	}
+	return 0;
+}
+
+static
+int
+mpdccptun_check_enqueue (tdat, skb)
+	struct mpdccptun	*tdat;
+	struct sk_buff		*skb;
+{
+	if (!tdat || !skb) return -EINVAL;
+	if (!tdat->wasconnected) return -ENOTCONN;
+	if (!tdat->isconnected) {
+		/* we allow for enqueuing for up to 1 minute */
+		if (jiffies > tdat->last_unconnect + 60*HZ) return -ENOTCONN;
+		/* do not allow prot 1 message */
+		if (TP_ISPROT1(skb->data[0])) return -ENOTCONN;
+	}
+	/* we are allowed - now check for queue */
+	if (tpq_isfull (&tdat->xmit_queue)) {
+		return tdat->isconnected ? -EAGAIN : -ENOTCONN;
+	}
+	if ((!tdat->isconnected) &&
+			(tdat->xmit_queue.policy == TP_QUEUE_INF &&
+			tdat->xmit_queue.queue.qlen >= 10000)) {
+		return -ENOTCONN;
+	}
+	return 0;
+}
+
+static
+void
+xmit_handler (work)
+	struct work_struct	*work;
+{
+	struct mpdccptun	*tdat;
+
+	if (!work) return;
+	tdat = container_of (work, struct mpdccptun, work_xmit);
+	do_xmit_handler (tdat);
+}
+
+static
+void
+xmit_handler_delayed (work)
+	struct work_struct	*work;
+{
+	struct delayed_work	*dwork;
+	struct mpdccptun		*tdat;
+
+	if (!work) return;
+	dwork = container_of(work, struct delayed_work, work);
+	tdat = container_of (dwork, struct mpdccptun, work_xmit_delayed);
+	do_xmit_handler (tdat);
+}
+
+
+static
+void
+do_xmit_handler (tdat)
+	struct mpdccptun	*tdat;
+{
+	int	cnt=0;
+	int	ret;
+
+	if (!tdat) return;
+	tdat->has_delayed_work = 0;
+	while ((ret = mpdccptun_elab_xmit (tdat)) > 0) {
+		/* dequeue at most 5 skb's at a time - to give accept / connect
+		 * a chance to be executed - they are on the same queue
+		 */
+		if (++cnt > 5) break;
+	}
+	if (ret > 0) {
+		/* insert directly - there is still work to be done */
+		queue_work (system_wq, &tdat->work_xmit);
+	} else if (ret < 0) {
+		/* retry in one second */
+		tdat->has_delayed_work = 1;
+		queue_delayed_work (system_wq, &tdat->work_xmit_delayed, HZ);
+	}
+	return;
+}
+
+static
+int
+mpdccptun_elab_xmit (tdat)
+	struct mpdccptun	*tdat;
+{
+	struct sk_buff		*skb;
+	int					ret;
+	struct tp_queue	*q;
+
+	if (!tdat) return -EINVAL;
+	q = &tdat->xmit_queue;
+	skb = tpq_dequeue (q);
+	if (!skb) return 0;	/* no message to elaborate */
+	tp_debug3 ("packet dequeued");
+	ret = mpdccptun_elab_xmit2 (tdat, skb);
+	if (ret == -EAGAIN) {
+		tp_debug3 ("packet requeued");
+		tpq_requeue (q, skb);
+		return -EAGAIN;
+	}
+	if (ret < 0) {
+		tp_debug ("error xmit skb: %d", ret);
+		return ret;
+	}
+	return 1;
+}
+
+
+static
+int
+mpdccptun_elab_xmit2 (tdat, skb)
+	struct mpdccptun	*tdat;
+	struct sk_buff		*skb;
+{
+	int	ret, sz;
+
+	sz = skb->len;
+
+	ret = mpdccptun_xmit_skb (tdat, skb);
+	if (ret < 0) {
+		tdat->ndev->stats.tx_dropped++;
+		if (ret == -EAGAIN) {
+		} else {
+			tdat->ndev->stats.tx_errors++;
+			kfree_skb (skb);
+		}
+		tp_debug ("error %d - dropping packet\n", ret);
+		return ret;
+	}
+	tdat->ndev->stats.tx_packets++;
+	tdat->ndev->stats.tx_bytes+=sz;
+	return 0;
+}
+
+
+
+static
+int
+mpdccptun_xmit (tdat, data, sz, raddr)
+	struct mpdccptun	*tdat;
+	char					*data;
+	int					sz;
+	tp_addr_t			*raddr;
+{
+	struct sk_buff	*skb;
+	int				len, ret;
+
+	if (!tdat || !data || sz < 0) return -EINVAL;
+	len = mpdccptun_needheadroom (tdat);
+	tp_debug3 ("sending meta packet of size %d\n", sz);
+	skb = dev_alloc_skb (len + sz);
+	if (!skb) return -ENOMEM;
+	skb_reserve (skb, len);
+	memcpy (skb_put (skb, sz), data, sz);
+	ret = mpdccptun_do_enqueue (tdat, skb);
+	if (ret == -EAGAIN) {
+		kfree_skb (skb);
+	}
+	/* else: do not free skb - not even on error - already done */
+	return ret;
+}
+
+
+static
+int
+mpdccptun_prepare_skb (tdat, skb, expired)
+	struct mpdccptun	*tdat;
+	struct sk_buff		*skb;
+	int					*expired;
+{
+	struct iphdr		*iph;
+	struct ipv6hdr		*iph6;
+
+	if (!tdat || !skb || !expired) return -EINVAL;
+	*expired = 0;
+	mpdccptun_scrub_skb (skb);
+	switch (TP_GETPKTTYPE (skb->data[0])) {
+	case 4:
+		skb_reset_inner_network_header (skb);
+		skb_reset_network_header(skb);
+		iph = ip_hdr(skb);
+		if (iph->ttl<=1) {
+			*expired = 1;
+			return 0;
+		}
+		// TODO: recalculate header checksum
+		// iph->ttl--;
+		skb_set_inner_transport_header (skb, iph->ihl << 2);
+		break;
+	case 6:
+		skb_reset_inner_network_header (skb);
+		skb_reset_network_header(skb);
+		iph6 = ipv6_hdr (skb);
+		if (iph6->hop_limit<=1) {
+			*expired = 1;
+			return 0;
+		}
+		// TODO: recalculate header checksum
+		// iph6->hop_limit--;
+		break;
+	}
+
+	return 0;
+}
+
+
+static
+int
+mpdccptun_xmit_skb (tdat, skb)
+	struct mpdccptun	*tdat;
+	struct sk_buff		*skb;
+{
+	int					ret, len;
+
+	if (!skb) return -EINVAL;
+	if (!tdat) return -EINVAL;
+	if (ISSTOP(tdat)) {
+		tp_debug2 ("device %s marked for being stopped", tdat->name);
+		return -EPERM;
+	}
+
+	len = skb->len;
+	ret = do_xmit_skb (tdat, skb);
+	if (ret < 0) {
+		if (ret != -EAGAIN) {
+			tp_note ("error sending skb: %d\n", ret);
+		}
+		return ret;
+	}
+
+	tp_debug2 ("packet with %d bytes sent\n", len);
+
+	return len;
+}
+
+static
+int
+do_xmit_skb (tdat, skb)
+	struct mpdccptun	*tdat;
+	struct sk_buff		*skb;
+{
+	struct socket	*sock;
+	int				ret;
+
+	if (!tdat || !skb) return -EINVAL;
+	if (!tdat->listening) {
+		sock = tdat->sock;
+	} else {
+		sock = tdat->active;
+	}
+	if (!sock) return -ENOTCONN;
+#if IS_ENABLED(CONFIG_IP_MPDCCP)
+	if (tdat->ismpdccp) {
+		ret = mpdccp_xmit_skb (sock->sk, skb);
+	} else
+#endif
+	{
+		struct kvec		kvec = (struct kvec) {
+			.iov_base = skb->data,
+			.iov_len = skb->len,
+		};
+		struct msghdr	msg =  (struct msghdr) {
+			.msg_iter = {
+				.type = ITER_IOVEC,
+				.count = 1,
+				.kvec = &kvec,
+			},
+			.msg_flags = MSG_DONTWAIT,
+		};
+		ret = kernel_sendmsg (sock, &msg, &kvec, 1, skb->len);
+		if (ret == 0) kfree_skb (skb);
+	}
+	if (ret < 0) {
+		tp_note ("%s error sending message: %d",
+					tdat->ismpdccp ? "mpdccp" : "dccp", ret);
+		return ret;
+	}
+	return 0;
+}
+
+static
+void
+mpdccptun_scrub_skb (skb)
+   struct sk_buff *skb;
+{
+   if (!skb) return;
+   skb_orphan(skb);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+   skb->tstamp.tv64 = 0;
+#else
+   skb->tstamp = 0;
+#endif
+   skb->pkt_type = PACKET_HOST;
+   skb->skb_iif = 0;
+   skb_dst_drop(skb);
+   nf_reset_ct(skb);
+   nf_reset_trace(skb);
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,11,0)
+   skb->ignore_df = 0;
+   //secpath_reset(skb);
+# ifdef CONFIG_NET_SWITCHDEV
+   skb->offload_fwd_mark = 0;
+# endif
+#endif
+
+}
+
+
+
+
+static
+int
+mpdccptun_dorcv_all (tdat, sk)
+	struct mpdccptun	*tdat;
+	struct sock			*sk;
+{
+	int	ret=0;
+
+	if (!tdat) return -EINVAL;
+	while (!ISSTOP(tdat) && (ret = mpdccptun_dorcv2 (tdat, sk)) == 0);
+	if (ret == -EAGAIN) ret=0;
+	if (ret < 0)
+		tdat->ndev->stats.rx_errors++;
+	return ret;
+}
+
+
+
+static
+int
+mpdccptun_dorcv (tdat, sk)
+	struct mpdccptun	*tdat;
+	struct sock			*sk;
+{
+	int	ret;
+
+	if (!tdat) return -EINVAL;
+	if (ISSTOP(tdat)) return 0;
+	ret = mpdccptun_dorcv2 (tdat, sk);
+	if (ret == -EAGAIN) ret=0;
+	if (ret < 0)
+		tdat->ndev->stats.rx_errors++;
+	return ret;
+}
+
+static
+int
+mpdccptun_dorcv2 (tdat, sk)
+	struct mpdccptun	*tdat;
+	struct sock			*sk;
+{
+	int					ret;
+	struct sk_buff		*skb=NULL;
+
+	if (!tdat) return -EINVAL;
+	ret = dorcv_datagram (&skb, sk, MSG_DONTWAIT);
+	if (ret == -EAGAIN) return ret;
+	if (ret < 0) {
+		tp_note ("error receiving data: %d", ret);
+		return ret;
+	}
+	if (ret == 0 || !skb || !skb->data || skb->len==0) return 0;
+
+	ret = mpdccptun_elab_recv(tdat, skb);
+	if (ret < 0) {
+		if (ret == -EBADMSG)
+		tp_debug ("error receiving packet: %d", ret);
+		kfree_skb (skb);
+		return ret;
+	}
+	return 0;
+}
+
+
+
+static
+int
+mpdccptun_elab_recv (tdat, skb)
+	struct mpdccptun		*tdat;
+	struct sk_buff		*skb;
+{
+	int	ret, sz;
+
+	if (!tdat || !skb) return -EINVAL;
+	/* set fw mark */
+	/* we have to set it always - because it was a drop count in sock-recv */
+	if (TP_SKBISPROT1(skb)) {
+		return ldt_prot1_recv (tdat->tun, skb);
+	}
+
+	skb->dev = tdat->ndev;
+	switch (TP_GETPKTTYPE(skb->data[0])) {
+	case 4:
+		skb->protocol = htons (ETH_P_IP);
+		break;
+	case 6:
+		skb->protocol = htons (ETH_P_IPV6);
+		break;
+	default:
+		tp_debug ("received unsupported protocol %d", TP_GETPKTTYPE (skb->data[0]));
+		return -EBADMSG;
+	}
+
+	/* deliver packet to device */
+	tp_debug3 ("deliver to %s\n", tdat->name);
+	sz = skb->len;
+	ret = netif_rx (skb);
+	if (ret != NET_RX_SUCCESS) {
+		tp_debug ("packet (%d bytes) dropped by netif_rx\n", sz);
+		/* skb must not be freed here! */
+	}
+
+	tp_debug3 ("received %d bytes", sz);
+	/* done */
+	tdat->ndev->stats.rx_packets++;
+	tdat->ndev->stats.rx_bytes+=sz;
+	return 0;
+}
+
+
+
+static
+int
+dorcv_datagram (skbuf, sk, flags)
+	struct sk_buff		**skbuf;
+	struct sock			*sk;
+	int					flags;
+{
+	int				peeked, off=0, err=0, ret;
+	struct sk_buff	*skb;
+
+	if (!skbuf || !sk) return -EINVAL;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+	skb = __skb_recv_datagram (sk, flags, &peeked, &off, &err);
+#elseif LINUX_VERSION_CODE < KERNEL_VERSION(5,10,0)
+	skb = __skb_recv_datagram (sk, flags, NULL, &peeked, &off, &err);
+#else
+	skb = __skb_recv_datagram (sk, &sk->sk_receive_queue, flags, &off, &err);
+#endif
+	if (!skb) return err;
+	tp_debug3 ("receive datagramm of %d bytes\n", skb->len);
+
+/* workaround for kernel bug */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,14,110) && LINUX_VERSION_CODE < KERNEL_VERSION(4,15,0)
+	if (!skb->sk) {
+		/* assume bug */
+		skb->sk = sk;
+		skb->destructor = sock_rfree;
+	}
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0) && LINUX_VERSION_CODE < KERNEL_VERSION(4,19,0)
+	if (!skb->sk) {
+		tp_warn ("skb->sk is null - check for possible kernel bug!!!\n");
+	}
+#endif
+	ret = rcv_prepare_skb (skbuf, skb);
+	if (ret < 0) {
+		kfree_skb (skb);
+		return ret;
+	}
+	return ret;
+}
+
+static
+int
+rcv_prepare_skb (skbuf, skb)
+	struct sk_buff			**skbuf, *skb;
+{
+	struct sk_buff	*nskb;
+
+	/* clean some data */
+	mpdccptun_scrub_skb (skb);
+
+	if (mpdccptun_needrcvcpy (skb)) {
+		tp_debug3 ("copy packet\n");
+		if (in_interrupt() || in_atomic())
+			nskb = skb_copy (skb, GFP_ATOMIC);
+		else
+			nskb = skb_copy (skb, GFP_KERNEL);
+		if (!nskb) {
+			tp_err ("error in copying datagram\n");
+			return -ENOMEM;
+		}
+		kfree_skb (skb);
+		skb = nskb;
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
+   skb->data += ((struct dccp_hdr*)(skb->data))->dccph_doff * 4;
+   skb->len -= ((struct dccp_hdr*)(skb->data))->dccph_doff * 4;
+#endif
+
+	*skbuf = skb;
+	return skb->len;
+}
+
+static
+int
+mpdccptun_needrcvcpy (skb)
+	struct sk_buff	*skb;
+{
+	int				type;
+	unsigned char	*ptr;
+	int				len;
+
+	if (!skb) return 0;
+	if (skb_shinfo(skb)->nr_frags == 0 && !skb_shinfo(skb)->frag_list) return 0;
+	tp_debug3 ("skb is fragmented (nr_frags=%d, frag_list=%p)\n",
+					skb_shinfo(skb)->nr_frags, skb_shinfo(skb)->frag_list);
+	if (skb->len < sizeof (struct dccp_hdr) + 4) return 1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
+   ptr = skb->data + ((struct dccp_hdr*)(skb->data))->dccph_doff * 4;
+   len = skb->len - ((struct dccp_hdr*)(skb->data))->dccph_doff * 4;
+#else
+	ptr = skb->data;
+	len = skb->len;
+#endif
+	type = *ptr >> 4;
+	if (type == 2) {
+		/* authenticated packets are copied for now - we should change that */
+		return 1;
+	}
+	switch (type) {
+	case 4:
+		if (len < sizeof (struct iphdr)) return 1;
+		/* the ip headr must fully fit into main fragment */
+		if (len < ((struct iphdr*)ptr)->ihl * 4) return 1;
+		return 0;
+	case 6:
+		if (len < 1260) return 1;
+		return 0;
+	}
+	/* internal packets are copied */
+	return 1;
+}
+
+
+
+
+static
+void
+tp_set_tdat (sock, tdat)
+	struct socket		*sock;
+	struct mpdccptun	*tdat;
+{
+	struct sock			*sk = sock ? sock->sk : NULL;
+
+	if (!sk) return;
+	sk->sk_user_data = tdat;
+#if IS_ENABLED(CONFIG_IP_MPDCCP)
+	if (tdat && tdat->ismpdccp)
+		tp_subflow_reg (sk);
+#endif
+}
+
+static
+void
+tp_unset_tdat (sock)
+	struct socket		*sock;
+{
+	struct sock			*sk = sock ? sock->sk : NULL;
+#if IS_ENABLED(CONFIG_IP_MPDCCP)
+	struct mpdccptun	*tdat;
+#endif
+
+	if (!sk) return;
+#if IS_ENABLED(CONFIG_IP_MPDCCP)
+	tdat = sk->sk_user_data;
+	if (tdat && tdat->ismpdccp)
+		tp_subflow_dereg (sk);
+#endif
+	sk->sk_user_data = NULL;
+}
+
+static
+void
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0)
+tp_cli_data_ready (sk, bytes)
+	struct sock	*sk;
+	int			bytes;
+#else
+tp_cli_data_ready (sk)
+	struct sock	*sk;
+#endif
+{
+	tp_elab_data_ready (sk);
+}
+
+static
+void
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0)
+tp_srv_data_ready (sk, bytes)
+	struct sock	*sk;
+	int			bytes;
+#else
+tp_srv_data_ready (sk)
+	struct sock	*sk;
+#endif
+{
+	tp_elab_data_ready (sk);
+}
+
+static
+void
+tp_elab_data_ready (sk)
+	struct sock	*sk;
+{
+	struct mpdccptun	*tdat;
+
+	if (!sk) return;
+	tp_debug3 ("new packet arrived\n");
+	tdat = sk->sk_user_data;
+	if (!ISMPDCCPTUN(tdat) || !tdat->bound) {
+		tp_debug ("no data structure in socket\n");
+		return;
+	}
+	mpdccptun_dorcv (tdat, sk);
+}
+
+
+static
+void
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0)
+tp_listen_ready (sk, bytes)
+	struct sock	*sk;
+	int			bytes;
+#else
+tp_listen_ready (sk)
+	struct sock	*sk;
+#endif
+{
+	struct mpdccptun	*tdat;
+	int					ret;
+
+	if (!sk) return;
+	tp_debug ("new connection request arrived\n");
+	tdat = sk->sk_user_data;
+	if (!ISMPDCCPTUN(tdat) || !tdat->bound) {
+		tp_err ("no data structure in socket\n");
+		return;
+	}
+	ret = queue_work (system_wq, &tdat->work_accept);
+	if (ret < 0) {
+		tp_err ("error in scheduling accept: %d\n", ret);
+		return;
+	}
+}
+
+static
+void
+accept_handler(work)
+	struct work_struct	*work;
+{
+	struct mpdccptun	*tdat;
+	int					ret;
+
+	if (!work) return;
+	tdat = container_of (work, struct mpdccptun, work_accept);
+	tp_debug3 ("tdat=%p, tun=%p\n", tdat, tdat->tun);
+	ret = mpdccptun_elab_accept (tdat);
+	if (ret < 0) {
+		tp_err ("error accepting connection: %d\n", ret);
+		ldt_event_crsend (LDT_EVTYPE_CONN_ACCEPT_FAIL, tdat->tun, 0);
+		return;
+	}
+	tp_debug2("new connection accepted");
+	ldt_event_crsend (LDT_EVTYPE_CONN_ACCEPT, tdat->tun, 0);
+	return;
+}
+
+static
+int
+mpdccptun_elab_accept (tdat)
+	struct mpdccptun	*tdat;
+{
+	struct socket	*sock;
+	struct socket	*sk_todel = NULL;
+	int				ret;
+
+	if (!tdat) return -EINVAL;
+	ret = kernel_accept (tdat->sock, &sock, O_NONBLOCK);
+	if (ret < 0) {
+		tp_err ("error accepting connection: %d", ret);
+		return ret;
+	}
+	DOLOCK (tdat);
+	if (tdat->active) {
+		tp_unset_tdat (tdat->active);
+		sk_todel = tdat->active;
+	}
+	tp_debug ("connection accepted, becoming active");
+	tdat->active = sock;
+	tp_set_tdat (sock, tdat);
+	sock->sk->sk_data_ready = tp_srv_data_ready;
+	tdat->isconnected = 1;
+	tdat->wasconnected = 1;
+	DOUNLOCK (tdat);
+	if (sk_todel)
+		_myclose (sk_todel);
+	/* to avoid race */
+	tp_debug ("receive already queued data");
+	lock_sock (sock->sk);
+	mpdccptun_dorcv_all (tdat, sock->sk);
+	release_sock (sock->sk);
+	tp_debug2 ("done");
+	return 0;
+}
+
+
+static
+void
+_myclose (sock)
+	struct socket	*sock;
+{
+	if (!sock) return;
+	kernel_sock_shutdown(sock, SHUT_RDWR);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,2,0)
+	sk_release_kernel(sock->sk);
+#else
+	sock_release (sock);
+#endif
+}
+
+
+
+#if IS_ENABLED(CONFIG_IP_MPDCCP)
+
+#ifdef MPDCCP_SUBFLOW_NOTIFIER
+static int tp_subflow_cb (struct notifier_block*, unsigned long, void*);
+static struct notifier_block tp_subflow_notifier = {
+	.notifier_call = tp_subflow_cb,
+};
+
+static
+int
+tp_subflow_reg (
+	struct sock *sk)
+{
+	return 0;
+}
+
+static
+int
+tp_subflow_dereg (
+	struct sock *sk)
+{
+	return 0;
+}
+
+static
+int
+tp_subflow_global_reg ()
+{
+	return register_mpdccp_subflow_notifier (&tp_subflow_notifier);
+}
+
+static
+int
+tp_subflow_global_dereg ()
+{
+	return unregister_mpdccp_subflow_notifier (&tp_subflow_notifier);
+}
+
+static
+int
+tp_subflow_cb (nblk, event, ptr)
+	struct notifier_block	*nblk;
+	unsigned long		event;
+	void			*ptr;
+{
+	struct mpdccp_subflow_notifier	*info = ptr;
+
+	tp_subflow_report ((int)event, info->sk, info->subsk, info->link, info->role);
+	return NOTIFY_DONE;
+}
+
+#else
+/* do it the old way */
+
+static
+int
+tp_subflow_global_reg ()
+{
+	return 0;
+}
+
+static
+int
+tp_subflow_global_dereg ()
+{
+	return 0;
+}
+
+
+static
+int
+tp_subflow_reg (
+	struct sock	*sk)
+{
+	return mpdccp_set_subflow_report (sk, tp_subflow_report);
+}
+
+static
+int
+tp_subflow_dereg (
+	struct sock *sk)
+{
+	return mpdccp_set_subflow_report (sk, NULL);
+}
+
+#endif
+
+/* for backward compatibility with older version of mpdccp */
+#ifndef MPDCCP_EV_SUBFLOW_DESTROY
+#  define MPDCCP_EV_SUBFLOW_DESTROY MPDCCP_SUBFLOW_DESTROY
+#endif
+#ifndef MPDCCP_EV_SUBFLOW_CREATE
+#  define MPDCCP_EV_SUBFLOW_CREATE MPDCCP_SUBFLOW_CREATE
+#endif
+
+static
+void
+tp_subflow_report (action, meta_sk, sk, link, role)
+	int							action, role;
+	struct sock					*meta_sk, *sk;
+	struct mpdccp_link_info	*link;
+{
+	struct mpdccptun		*tdat;
+	subflow_str				*p;
+	const char				*name;
+	int						i, ret;
+
+	if (!meta_sk || !link) return;
+	tdat = meta_sk->sk_user_data;
+	if (!ISMPDCCPTUN(tdat) || ISSTOP(tdat)) {
+		return;
+	}
+	if (link->is_devlink) {
+		name = link->ndev_name;
+	} else {
+		name = link->name;
+	}
+	if (!name) name = "unnamed";
+	switch (action) {
+	case MPDCCP_EV_SUBFLOW_CREATE:
+		tp_info ("add subflow %s\n", name);
+		DOLOCK2(tdat);
+		if (tdat->num_subflow >= tdat->bufsz_subflow) {
+			if (in_atomic()) {
+				p = krealloc (tdat->subflow, sizeof (subflow_str) * (tdat->bufsz_subflow+1), GFP_ATOMIC);
+			} else {
+				p = krealloc (tdat->subflow, sizeof (subflow_str) * (tdat->bufsz_subflow+1), GFP_KERNEL);
+			}
+			if (!p) {
+				DOUNLOCK2(tdat);
+				return;
+			}
+			tdat->subflow = p;
+			tdat->bufsz_subflow++;
+		}
+		strcpy (tdat->subflow[tdat->num_subflow].s, name);
+		tdat->num_subflow++;
+		DOUNLOCK2(tdat);
+		strcpy (tdat->subflow_report.s, name);
+		tdat->has_subflow_report = 1;
+		ret = ldt_event_crsend (LDT_EVTYPE_SUBFLOW_UP, tdat->tun, 0);
+		if (ret < 0) {
+			tp_err ("error sending subflow up event: %d\n", ret);
+		}
+		tdat->has_subflow_report = 0;
+		break;
+	case MPDCCP_EV_SUBFLOW_DESTROY:
+		tp_info ("remove subflow %s\n", name);
+		DOLOCK2(tdat);
+		for (i=0; i<tdat->num_subflow; i++) {
+			if (!strcasecmp (name, tdat->subflow[i].s)) {
+				for (; i<tdat->num_subflow-1; i++) {
+					strcpy (tdat->subflow[i].s, tdat->subflow[i+1].s);
+				}
+				tdat->subflow[i].s[0] = 0;
+				tdat->num_subflow--;
+				break;
+			}
+		}
+		DOUNLOCK2(tdat);
+
+		strcpy (tdat->subflow_report.s, name);
+		tdat->has_subflow_report = 1;
+		ret = ldt_event_crsend (LDT_EVTYPE_SUBFLOW_DOWN, tdat->tun, 0);
+		if (ret < 0) {
+			tp_err ("error sending subflow down event: %d\n", ret);
+		}
+		tdat->has_subflow_report = 0;
+		break;
+#ifdef MPDCCP_EV_ALL_SUBFLOW_DOWN
+	case MPDCCP_EV_ALL_SUBFLOW_DOWN:
+		mpdccptun_linkdown (tdat);
+		break;
+#endif
+	}
+	return;
+}
+
+
+static
+int
+mpdccptun_linkdown (tdat)
+	struct mpdccptun	*tdat;
+{
+	if (!tdat) return -EINVAL;
+	if (tdat->listening) {
+		MYCLOSE (tdat, active);
+		return 0;
+	}
+	/* we are client and need to reconnect - TBD */
+	tdat->last_unconnect = jiffies;
+	tdat->isconnected = 0;
+	MYCLOSE(tdat, sock);
+	return 0;
+}
+
+
+#endif
+
+
+
+
+
+
+/*
+ * Overrides for XEmacs and vim so that we get a uniform tabbing style.
+ * XEmacs/vim will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 3
+ * c-basic-offset: 3
+ * tab-width: 3
+ * End:
+ * vim:tw=0:ts=3:wm=0:
+ */
diff --git a/net/ldt/ldt_mpdccp.h b/net/ldt/ldt_mpdccp.h
new file mode 100644
index 0000000000000..f6986276c6fca
--- /dev/null
+++ b/net/ldt/ldt_mpdccp.h
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2015-2022 by Frank Reker, Deutsche Telekom AG
+ *
+ * LDT - Lightweight (MP-)DCCP Tunnel kernel module
+ *
+ * This is not Open Source software.
+ * This work is made available to you under a source-available license, as
+ * detailed below.
+ *
+ * Copyright 2022 Deutsche Telekom AG
+ *
+ * Permission is hereby granted, free of charge, subject to below Commons
+ * Clause, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * “Commons Clause” License Condition v1.0
+ *
+ * The Software is provided to you by the Licensor under the License, as
+ * defined below, subject to the following condition.
+ *
+ * Without limiting other conditions in the License, the grant of rights under
+ * the License will not include, and the License does not grant to you, the
+ * right to Sell the Software.
+ *
+ * For purposes of the foregoing, “Sell” means practicing any or all of the
+ * rights granted to you under the License to provide to third parties, for a
+ * fee or other consideration (including without limitation fees for hosting
+ * or consulting/ support services related to the Software), a product or
+ * service whose value derives, entirely or substantially, from the
+ * functionality of the Software. Any license notice or attribution required
+ * by the License must also include this Commons Clause License Condition
+ * notice.
+ *
+ * Licensor: Deutsche Telekom AG
+ */
+
+#ifndef _R__KERNEL_LDT_MPDCCP_INT_H
+#define _R__KERNEL_LDT_MPDCCP_INT_H
+
+#include <linux/types.h>
+
+int ldt_mpdccp_register (void);
+void ldt_mpdccp_unregister (void);
+
+
+
+
+
+
+#endif	/* _R__KERNEL_LDT_MPDCCP_INT_H */
+
+/*
+ * Overrides for XEmacs and vim so that we get a uniform tabbing style.
+ * XEmacs/vim will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 3
+ * c-basic-offset: 3
+ * tab-width: 3
+ * End:
+ * vim:tw=0:ts=3:wm=0:
+ */
diff --git a/net/ldt/ldt_netlink.c b/net/ldt/ldt_netlink.c
new file mode 100644
index 0000000000000..163f725f606b9
--- /dev/null
+++ b/net/ldt/ldt_netlink.c
@@ -0,0 +1,1309 @@
+/*
+ * Copyright (C) 2015-2022 by Frank Reker, Deutsche Telekom AG
+ *
+ * LDT - Lightweight (MP-)DCCP Tunnel kernel module
+ *
+ * This is not Open Source software.
+ * This work is made available to you under a source-available license, as
+ * detailed below.
+ *
+ * Copyright 2022 Deutsche Telekom AG
+ *
+ * Permission is hereby granted, free of charge, subject to below Commons
+ * Clause, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * “Commons Clause” License Condition v1.0
+ *
+ * The Software is provided to you by the Licensor under the License, as
+ * defined below, subject to the following condition.
+ *
+ * Without limiting other conditions in the License, the grant of rights under
+ * the License will not include, and the License does not grant to you, the
+ * right to Sell the Software.
+ *
+ * For purposes of the foregoing, “Sell” means practicing any or all of the
+ * rights granted to you under the License to provide to third parties, for a
+ * fee or other consideration (including without limitation fees for hosting
+ * or consulting/ support services related to the Software), a product or
+ * service whose value derives, entirely or substantially, from the
+ * functionality of the Software. Any license notice or attribution required
+ * by the License must also include this Commons Clause License Condition
+ * notice.
+ *
+ * Licensor: Deutsche Telekom AG
+ */
+
+
+#include <linux/socket.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/netlink.h>
+#include <net/sock.h>
+#include <net/tcp_states.h>
+#include <net/genetlink.h>
+#include <linux/skbuff.h>
+#include <linux/notifier.h>
+#include <linux/version.h>
+
+#include "ldt_uapi.h"
+#include "ldt_version.h"
+#include "ldt_dev.h"
+#include "ldt_debug.h"
+#include "ldt_event.h"
+#include "ldt_netlink.h"
+#include "ldt_lock.h"
+
+
+int ldt_nl_family_id = 0;
+
+static struct tp_lock ldt_nl_mutex;
+#define G_LOCK    do { tp_lock (&ldt_nl_mutex); } while (0)
+#define G_UNLOCK  do { tp_unlock (&ldt_nl_mutex); } while (0)
+
+
+static int ldt_nl_create_dev (struct sk_buff*, struct genl_info*);
+static int ldt_nl_rm_dev (struct sk_buff*, struct genl_info*);
+static int ldt_nl_get_version (struct sk_buff*, struct genl_info*);
+static int ldt_nl_get_devlist (struct sk_buff*, struct genl_info*);
+static int ldt_nl_show_dev (struct sk_buff*, struct genl_info*);
+static int ldt_nl_show_devlist (struct sk_buff*, struct genl_info*);
+static int ldt_nl_rm_tun (struct sk_buff*, struct genl_info*);
+static int ldt_nl_newtun (struct sk_buff*, struct genl_info*);
+static int ldt_nl_bind (struct sk_buff*, struct genl_info*);
+static int ldt_nl_bind2dev (struct sk_buff*, struct genl_info*);
+static int ldt_nl_peer (struct sk_buff*, struct genl_info*);
+static int ldt_nl_serverstart (struct sk_buff*, struct genl_info*);
+static int ldt_nl_set_mtu (struct sk_buff*, struct genl_info*);
+static int ldt_nl_set_queue (struct sk_buff*, struct genl_info*);
+static int ldt_nl_evsend (struct sk_buff*, struct genl_info*);
+static int ldt_nl_subscribe (struct sk_buff*, struct genl_info*);
+
+static int ldt_nl_release_notifier (struct notifier_block*, unsigned long, void*);
+static int send_info (struct net*, u32, int, const char *, u32);
+static int send_ret (struct net*, u32, int);
+static int ldt_nl_adduser (u32, struct net*);
+static void ldt_nl_rmuser (u32, struct net*);
+static void ldt_nl_rmalluser (void);
+static int do_send_event (struct net*, u32, u32, u32, const char*);
+
+
+
+
+
+static const struct nla_policy ldt_nl_policy_create_dev[LDT_CMD_CREATE_DEV_ATTR_MAX + 1] = {
+	[LDT_CMD_CREATE_DEV_ATTR_NAME]	= {	.type = NLA_NUL_STRING },
+	[LDT_CMD_CREATE_DEV_ATTR_FLAGS]	= {	.type = NLA_U32 },
+};
+
+static const struct nla_policy ldt_nl_policy_rm_dev[LDT_CMD_RM_DEV_ATTR_MAX + 1] = {
+	[LDT_CMD_RM_DEV_ATTR_NAME]	= {	.type = NLA_NUL_STRING },
+};
+
+
+static const struct nla_policy ldt_nl_policy_get_version[LDT_CMD_GET_VERSION_ATTR_MAX+1] = {};
+
+static const struct nla_policy ldt_nl_policy_get_devlist[LDT_CMD_GET_DEVLIST_ATTR_MAX+1] = {};
+
+static const struct nla_policy ldt_nl_policy_show_dev[LDT_CMD_SHOW_DEV_ATTR_MAX+1] = {
+	[LDT_CMD_SHOW_DEV_ATTR_NAME]	= {	.type = NLA_NUL_STRING },
+};
+
+static const struct nla_policy ldt_nl_policy_show_devlist[LDT_CMD_SHOW_DEVLIST_ATTR_MAX+1] = {};
+
+
+static const struct nla_policy ldt_nl_policy_rm_tun[LDT_CMD_RM_TUN_ATTR_MAX + 1] = {
+	[LDT_CMD_RM_TUN_ATTR_NAME] 	= {	.type = NLA_NUL_STRING },
+};
+
+static const struct nla_policy ldt_nl_policy_newtun[LDT_CMD_NEWTUN_ATTR_MAX + 1] = {
+	[LDT_CMD_NEWTUN_ATTR_NAME] 	= {	.type = NLA_NUL_STRING },
+	[LDT_CMD_NEWTUN_ATTR_TUN_TYPE] 	= {	.type = NLA_NUL_STRING },
+};
+
+static const struct nla_policy ldt_nl_policy_bind[LDT_CMD_BIND_ATTR_MAX + 1] = {
+	[LDT_CMD_BIND_ATTR_NAME] 		= {	.type = NLA_NUL_STRING },
+	[LDT_CMD_BIND_ATTR_ADDR4]		= {	.type = NLA_U32 },
+	[LDT_CMD_BIND_ATTR_ADDR6] 	= {	.type = NLA_BINARY },
+	[LDT_CMD_BIND_ATTR_PORT]		= {	.type = NLA_U16 },
+};
+
+static const struct nla_policy ldt_nl_policy_bind2dev[LDT_CMD_BIND2DEV_ATTR_MAX + 1] = {
+	[LDT_CMD_BIND2DEV_ATTR_NAME] 		= {	.type = NLA_NUL_STRING },
+	[LDT_CMD_BIND2DEV_ATTR_DEV] 		= {	.type = NLA_NUL_STRING },
+};
+
+static const struct nla_policy ldt_nl_policy_peer[LDT_CMD_PEER_ATTR_MAX + 1] = {
+	[LDT_CMD_PEER_ATTR_NAME] 	= {	.type = NLA_NUL_STRING },
+	[LDT_CMD_PEER_ATTR_ADDR4]	= {	.type = NLA_U32 },
+	[LDT_CMD_PEER_ATTR_ADDR6] = {	.type = NLA_BINARY },
+	[LDT_CMD_PEER_ATTR_PORT]	= {	.type = NLA_U16 },
+};
+
+static const struct nla_policy ldt_nl_policy_serverstart[LDT_CMD_SERVERSTART_ATTR_MAX + 1] = {
+	[LDT_CMD_SERVERSTART_ATTR_NAME] 	= {	.type = NLA_NUL_STRING },
+};
+
+static const struct nla_policy ldt_nl_policy_set_mtu[LDT_CMD_SET_MTU_ATTR_MAX + 1] = {
+	[LDT_CMD_SET_MTU_ATTR_NAME]		= { .type = NLA_NUL_STRING },
+	[LDT_CMD_SET_MTU_ATTR_MTU]		= { .type = NLA_U32 },
+};
+
+
+static const struct nla_policy ldt_nl_policy_set_queue[LDT_CMD_SETQUEUE_ATTR_MAX + 1] = {
+   [LDT_CMD_SETQUEUE_ATTR_NAME]		= { .type = NLA_NUL_STRING },
+   [LDT_CMD_SETQUEUE_ATTR_TXQLEN]	= { .type = NLA_U16 },
+   [LDT_CMD_SETQUEUE_ATTR_QPOLICY]	= { .type = NLA_U16 },
+};
+
+
+static const struct nla_policy ldt_nl_policy_evsend[LDT_CMD_EVSEND_ATTR_MAX + 1] = {
+	[LDT_CMD_EVSEND_ATTR_NAME]		= { .type = NLA_NUL_STRING },
+	[LDT_CMD_EVSEND_ATTR_EVTYPE]	= { .type = NLA_U32 },
+	[LDT_CMD_EVSEND_ATTR_REASON]	= { .type = NLA_U32 },
+};
+
+static const struct nla_policy ldt_nl_policy_subscribe[LDT_CMD_GET_VERSION_ATTR_MAX+1] = {};
+
+
+static const struct genl_ops ldt_nl_ops[] = {
+	{
+		.cmd = LDT_CMD_CREATE_DEV,
+		.flags = GENL_ADMIN_PERM,
+		.doit = ldt_nl_create_dev,
+		.policy = ldt_nl_policy_create_dev,
+	},
+	{
+		.cmd = LDT_CMD_RM_DEV,
+		.flags = GENL_ADMIN_PERM,
+		.doit = ldt_nl_rm_dev,
+		.policy = ldt_nl_policy_rm_dev,
+	},
+	{
+		.cmd = LDT_CMD_GET_VERSION,
+		.doit = ldt_nl_get_version,
+		.policy = ldt_nl_policy_get_version,
+		/* can be retrieved by unprivileged users */
+	},
+	{
+		.cmd = LDT_CMD_SHOW_DEV,
+		.doit = ldt_nl_show_dev,
+		.policy = ldt_nl_policy_show_dev,
+		/* can be retrieved by unprivileged users */
+	},
+	{
+		.cmd = LDT_CMD_GET_DEVLIST,
+		.doit = ldt_nl_get_devlist,
+		.policy = ldt_nl_policy_get_devlist,
+		/* can be retrieved by unprivileged users */
+	},
+	{
+		.cmd = LDT_CMD_SHOW_DEVLIST,
+		.doit = ldt_nl_show_devlist,
+		.policy = ldt_nl_policy_show_devlist,
+		/* can be retrieved by unprivileged users */
+	},
+	{
+		.cmd = LDT_CMD_RM_TUN,
+		.flags = GENL_ADMIN_PERM,
+		.doit = ldt_nl_rm_tun,
+		.policy = ldt_nl_policy_rm_tun,
+	},
+	{
+		.cmd = LDT_CMD_NEWTUN,
+		.flags = GENL_ADMIN_PERM,
+		.doit = ldt_nl_newtun,
+		.policy = ldt_nl_policy_newtun,
+	},
+	{
+		.cmd = LDT_CMD_BIND,
+		.flags = GENL_ADMIN_PERM,
+		.doit = ldt_nl_bind,
+		.policy = ldt_nl_policy_bind,
+	},
+	{
+		.cmd = LDT_CMD_BIND2DEV,
+		.flags = GENL_ADMIN_PERM,
+		.doit = ldt_nl_bind2dev,
+		.policy = ldt_nl_policy_bind2dev,
+	},
+	{
+		.cmd = LDT_CMD_PEER,
+		.flags = GENL_ADMIN_PERM,
+		.doit = ldt_nl_peer,
+		.policy = ldt_nl_policy_peer,
+	},
+	{
+		.cmd = LDT_CMD_SERVERSTART,
+		.flags = GENL_ADMIN_PERM,
+		.doit = ldt_nl_serverstart,
+		.policy = ldt_nl_policy_serverstart,
+	},
+	{
+		.cmd = LDT_CMD_SET_MTU,
+		.flags = GENL_ADMIN_PERM,
+		.doit = ldt_nl_set_mtu,
+		.policy = ldt_nl_policy_set_mtu,
+	},
+	{
+		.cmd = LDT_CMD_SET_QUEUE,
+		.flags = GENL_ADMIN_PERM,
+		.doit = ldt_nl_set_queue,
+		.policy = ldt_nl_policy_set_queue,
+	},
+	{
+		.cmd = LDT_CMD_EVSEND,
+		.flags = GENL_ADMIN_PERM,
+		.doit = ldt_nl_evsend,
+		.policy = ldt_nl_policy_evsend,
+	},
+	{
+		.cmd = LDT_CMD_SUBSCRIBE,
+		.doit = ldt_nl_subscribe,
+		.policy = ldt_nl_policy_subscribe,
+		/* can be retrieved by unprivileged users */
+	},
+};
+
+static struct genl_family ldt_nl_family = {
+	.name = LDT_NAME,
+	.hdrsize = 0,
+	.version = LDT_NL_VERSION,
+	.maxattr = LDT_CMD_MAX,
+	.netnsok = true,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+	.id = GENL_ID_GENERATE,
+#else
+	.module = THIS_MODULE,
+	.ops = ldt_nl_ops,
+	.n_ops = ARRAY_SIZE (ldt_nl_ops),
+#endif
+};
+
+
+
+static struct notifier_block ldt_netlink_notifier = {
+        .notifier_call = ldt_nl_release_notifier
+};
+
+struct ldt_nl_user {
+	struct list_head			list;
+	struct list_head			dellist;
+	u32							pid;
+	struct net					*net;
+	int							valid;
+};
+
+#define LDT_NL_USER_NULL ((struct ldt_nl_user) { .valid = 0, })
+
+//static struct list_head	tpnl_head = (struct list_head) { .next = &tpnl_head, .prev = &tpnl_head };
+static struct list_head	tpnl_head;
+
+
+int
+ldt_nl_register (void)
+{
+	int	ret;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0)
+	struct genl_ops	*ops;
+	int					nops = ARRAY_SIZE (ldt_nl_ops);
+#endif
+
+	INIT_LIST_HEAD (&tpnl_head);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0)
+	ops = kmalloc (sizeof (struct genl_ops)*nops, GFP_KERNEL);
+	if (!ops) return -ENOMEM;
+	memcpy (ops, ldt_nl_ops, nops*sizeof (struct genl_ops));
+	ret = genl_register_family_with_ops (&ldt_nl_family, ops, nops);
+	if (ret < 0)
+		kfree (ops);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+	ret = genl_register_family_with_ops (&ldt_nl_family, ldt_nl_ops);
+#else
+	ret = genl_register_family (&ldt_nl_family);
+#endif
+	if (ret < 0) return ret;
+	ret = netlink_register_notifier (&ldt_netlink_notifier);
+	if (ret < 0) {
+		genl_unregister_family (&ldt_nl_family);
+		return ret;
+	}
+	ldt_nl_family_id = ldt_nl_family.id;
+	tp_prtk ("registered with id %d\n", ldt_nl_family_id);
+	return 0;
+}
+
+void
+ldt_nl_unregister (void)
+{
+	genl_unregister_family (&ldt_nl_family);
+	netlink_unregister_notifier (&ldt_netlink_notifier);
+	ldt_nl_rmalluser();
+}
+
+
+
+
+
+static
+int
+ldt_nl_create_dev (skb, info)
+	struct sk_buff		*skb;
+	struct genl_info	*info;
+{
+	const char					*name;
+	u32							pid;
+	const struct nlmsghdr	*nlh;
+	const struct nlattr		*attr;
+	struct net					*net;
+	int							ret;
+	int							flags;
+
+	if (!skb) return -EINVAL;
+	if (!info) return -EINVAL;
+	nlh = nlmsg_hdr(skb);
+	if (!nlh) return -EINVAL;
+	pid = nlh->nlmsg_pid;
+	net = genl_info_net (info);
+	if (!net) return -EINVAL;
+	attr = info->attrs[LDT_CMD_CREATE_DEV_ATTR_NAME];
+	if (attr) {
+		name = (const char*)nla_data (attr);
+		if (name && !*name) name=NULL;
+	} else {
+		name = NULL;
+	}
+	attr = info->attrs[LDT_CMD_CREATE_DEV_ATTR_FLAGS];
+	if (attr) {
+		flags = (int)nla_get_u32 (attr);
+	} else {
+		flags = 0;
+	}
+	tp_debug ("add device %s (flags=%x)\n",
+						name?name:"tp%d", flags);
+	ret = ldt_create_dev (net, name, &name, flags);
+	if (ret < 0 || !name || !*name) return send_ret (net, pid, ret);
+	return send_info (net, pid, 0, name, strlen (name) + 1);
+}
+
+static
+int
+ldt_nl_rm_dev (skb, info)
+	struct sk_buff		*skb;
+	struct genl_info	*info;
+{
+	const char					*name;
+	u32							pid;
+	const struct nlmsghdr	*nlh;
+	const struct nlattr		*attr;
+	struct net					*net;
+
+	if (!skb) return -EINVAL;
+	if (!info) return -EINVAL;
+	nlh = nlmsg_hdr(skb);
+	if (!nlh) return -EINVAL;
+	pid = nlh->nlmsg_pid;
+	net = genl_info_net (info);
+	if (!net) return -EINVAL;
+	attr = info->attrs[LDT_CMD_RM_DEV_ATTR_NAME];
+	if (!attr) return send_ret (net, pid, -EINVAL);
+	name = (const char*)nla_data (attr);
+	tp_debug ("remove device %s\n", name);
+	ldt_free_dev (LDTDEV_BYNAME (net, name));
+	return send_ret (net, pid, 0);
+}
+
+static
+int
+ldt_nl_get_version (skb, info)
+	struct sk_buff		*skb;
+	struct genl_info	*info;
+{
+	u32							pid;
+	const struct nlmsghdr	*nlh;
+	struct net					*net;
+	int							ret;
+
+	if (!skb) return -EINVAL;
+	nlh = nlmsg_hdr(skb);
+	if (!nlh) return -EINVAL;
+	pid = nlh->nlmsg_pid;
+	if (!info) return -EINVAL;
+	net = genl_info_net (info);
+	if (!net) return -EINVAL;
+	tp_debug ("return ldt version %s", LDT_VERSION);
+	ret = send_info (net, pid, 0, LDT_VERSION, strlen (LDT_VERSION)+1);
+	if (ret < 0) return ret;
+	return 0;
+}
+
+static
+int
+ldt_nl_get_devlist (skb, info)
+	struct sk_buff		*skb;
+	struct genl_info	*info;
+{
+	u32							pid;
+	const struct nlmsghdr	*nlh;
+	struct net					*net;
+	int							ret;
+	char							*data;
+	u32							len;
+
+	if (!skb) return -EINVAL;
+	nlh = nlmsg_hdr(skb);
+	if (!nlh) return -EINVAL;
+	pid = nlh->nlmsg_pid;
+	if (!info) return -EINVAL;
+	net = genl_info_net (info);
+	if (!net) return -EINVAL;
+	tp_debug ("show info for all devices\n");
+	ret = ldt_get_devlist (net, &data, &len);
+	if (ret < 0) return send_ret (net, pid, ret);
+	ret = send_info (net, pid, 0, data, len);
+	kfree (data);
+	if (ret < 0) return ret;
+	return 0;
+}
+
+static
+int
+ldt_nl_show_dev (skb, info)
+	struct sk_buff		*skb;
+	struct genl_info	*info;
+{
+	u32							pid;
+	const struct nlmsghdr	*nlh;
+	const struct nlattr		*attr;
+	const char					*name;
+	struct net					*net;
+	ssize_t						ret;
+	char							*data;
+	u32							len;
+	struct ldt_dev		*tdev;
+
+	if (!skb) return -EINVAL;
+	nlh = nlmsg_hdr(skb);
+	if (!nlh) return -EINVAL;
+	pid = nlh->nlmsg_pid;
+	if (!info) return -EINVAL;
+	net = genl_info_net (info);
+	if (!net) return -EINVAL;
+	attr = info->attrs[LDT_CMD_SHOW_DEV_ATTR_NAME];
+	if (!attr) return send_ret (net, pid, -EINVAL);
+	name = (const char*)nla_data (attr);
+	if (!name || !*name) return send_ret (net, pid, -EINVAL);
+	tp_debug ("show dev [%s]", name);
+	tdev = LDTDEV_BYNAME (net, name);
+	if (!tdev) return send_ret (net, pid, -EINVAL);
+	ret = ldt_get_devinfo (tdev, &data);
+	dev_put (tdev->ndev);
+	if (ret < 0) return send_ret (net, pid, ret);
+	len = (u32)ret;
+	ret = send_info (net, pid, 0, data, len);
+	kfree (data);
+	if (ret < 0) return ret;
+	return 0;
+}
+
+static
+int
+ldt_nl_show_devlist (skb, info)
+	struct sk_buff		*skb;
+	struct genl_info	*info;
+{
+	u32							pid;
+	const struct nlmsghdr	*nlh;
+	struct net					*net;
+	ssize_t						ret;
+	char							*data;
+	u32							len;
+
+	if (!skb) return -EINVAL;
+	nlh = nlmsg_hdr(skb);
+	if (!nlh) return -EINVAL;
+	pid = nlh->nlmsg_pid;
+	if (!info) return -EINVAL;
+	net = genl_info_net (info);
+	if (!net) return -EINVAL;
+	tp_debug ("show info for all devices\n");
+	ret = ldt_get_alldevinfo (net, &data);
+	if (ret < 0) return send_ret (net, pid, ret);
+	len = (u32)ret;
+	ret = send_info (net, pid, 0, data, len);
+	kfree (data);
+	if (ret < 0) return ret;
+	return 0;
+}
+
+static
+int
+ldt_nl_rm_tun (skb, info)
+	struct sk_buff		*skb;
+	struct genl_info	*info;
+{
+	u32							pid;
+	const struct nlmsghdr	*nlh;
+	const struct nlattr		*attr;
+	const char					*name;
+	struct net					*net;
+	int							ret;
+	struct ldt_dev		*tdev;
+
+	if (!skb) return -EINVAL;
+	nlh = nlmsg_hdr(skb);
+	if (!nlh) return -EINVAL;
+	pid = nlh->nlmsg_pid;
+	if (!info) return -EINVAL;
+	net = genl_info_net (info);
+	if (!net) return -EINVAL;
+	attr = info->attrs[LDT_CMD_RM_TUN_ATTR_NAME];
+	if (!attr) return send_ret (net, pid, -EINVAL);
+	name = (const char*)nla_data (attr);
+	tp_debug ("remove tunnel [%s]", name);
+	tdev = LDTDEV_BYNAME (net, name);
+	if (!tdev) return send_ret (net, pid, -EINVAL);
+	ret = ldt_rm_tun (tdev);
+	dev_put (tdev->ndev);
+	return send_ret (net, pid, ret);
+}
+
+
+static
+int
+ldt_nl_newtun (skb, info)
+	struct sk_buff		*skb;
+	struct genl_info	*info;
+{
+	u32							pid;
+	const struct nlmsghdr	*nlh;
+	const struct nlattr		*attr;
+	struct net					*net;
+	const char					*name;
+	const char					*tuntype;
+	int							ret;
+	struct ldt_dev		*tdev;
+
+	if (!skb) return -EINVAL;
+	nlh = nlmsg_hdr(skb);
+	if (!nlh) return -EINVAL;
+	pid = nlh->nlmsg_pid;
+	if (!info) return -EINVAL;
+	net = genl_info_net (info);
+	if (!net) return -EINVAL;
+	attr = info->attrs[LDT_CMD_NEWTUN_ATTR_NAME];
+	if (!attr) return send_ret (net, pid, -EINVAL);
+	name = (const char*)nla_data (attr);
+	attr = info->attrs[LDT_CMD_NEWTUN_ATTR_TUN_TYPE];
+	if (!attr) return send_ret (net, pid, -EINVAL);
+	tuntype = (const char*)nla_data (attr);
+	tp_debug ("create new tunnel [%s] of type %s\n", name, tuntype);
+	tdev = LDTDEV_BYNAME (net, name);
+	if (!tdev) return send_ret (net, pid, -EINVAL);
+	ret = ldt_dev_newtun (	tdev, tuntype);
+	dev_put (tdev->ndev);
+	return send_ret (net, pid, ret);
+}
+
+static
+int
+ldt_nl_bind (skb, info)
+	struct sk_buff		*skb;
+	struct genl_info	*info;
+{
+	u32							pid, addr4;
+	u8								addr6[16];
+	u16							port=0;
+	tp_addr_t					laddr;
+	const struct nlmsghdr	*nlh;
+	const struct nlattr		*attr;
+	const char					*name;
+	struct net					*net;
+	int							ret;
+	struct ldt_dev		*tdev;
+	int							ipv6, hasladdr;
+
+	if (!skb) return -EINVAL;
+	nlh = nlmsg_hdr(skb);
+	if (!nlh) return -EINVAL;
+	pid = nlh->nlmsg_pid;
+	if (!info) return -EINVAL;
+	net = genl_info_net (info);
+	if (!net) return -EINVAL;
+	attr = info->attrs[LDT_CMD_BIND_ATTR_NAME];
+	if (!attr) return send_ret (net, pid, -EINVAL);
+	name = (const char*)nla_data (attr);
+	hasladdr = 0;
+	attr = info->attrs[LDT_CMD_BIND_ATTR_ADDR4];
+	if (attr) {
+		addr4 = nla_get_u32 (attr);
+		hasladdr = 1;
+		ipv6 = 0;
+	} else {
+		attr = info->attrs[LDT_CMD_BIND_ATTR_ADDR6];
+		if (attr) {
+			if (nla_len(attr) != 16) return send_ret (net, pid, -EINVAL);
+			memcpy (addr6, nla_data (attr), 16);
+			hasladdr = 1;
+			ipv6 = 1;
+		}
+	}
+	if (hasladdr) {
+		attr = info->attrs[LDT_CMD_BIND_ATTR_PORT];
+		if (!attr) return send_ret (net, pid, -EINVAL);
+		port = nla_get_u16 (attr);
+		if (!ipv6) {
+			tp_addr_setipv4 (&laddr, addr4, port);
+		} else {
+			tp_addr_setipv6 (&laddr, addr6, port);
+		}
+	} else {
+		tp_addr_setipv4 (&laddr, 0, 0);
+		ipv6 = 0;
+	}
+
+	/* output always addr, due to a bug in android kernel, that cannot handle
+		NULL pointers in printk's %pI
+	 */
+	tp_debug ("bind tunnel [%s] to %pISc:%u\n", name, &laddr, (unsigned)port);
+	tdev = LDTDEV_BYNAME (net, name);
+	if (!tdev) {
+		tp_note ("cannot find device %s\n", name);
+		return send_ret (net, pid, -EINVAL);
+	}
+	tp_debug2 ("call ldt_dev_bind\n");
+	ret = ldt_dev_bind (tdev, &laddr);
+	dev_put (tdev->ndev);
+	tp_debug ("done -> %d\n", ret);
+	return send_ret (net, pid, ret);
+}
+
+static
+int
+ldt_nl_bind2dev (skb, info)
+	struct sk_buff		*skb;
+	struct genl_info	*info;
+{
+	u32							pid;
+	const char					*dev;
+	const struct nlmsghdr	*nlh;
+	const struct nlattr		*attr;
+	const char					*name;
+	struct net					*net;
+	int							ret;
+	struct ldt_dev		*tdev;
+
+	if (!skb) return -EINVAL;
+	nlh = nlmsg_hdr(skb);
+	if (!nlh) return -EINVAL;
+	pid = nlh->nlmsg_pid;
+	if (!info) return -EINVAL;
+	net = genl_info_net (info);
+	if (!net) return -EINVAL;
+	attr = info->attrs[LDT_CMD_BIND2DEV_ATTR_NAME];
+	if (!attr) return send_ret (net, pid, -EINVAL);
+	name = (const char*)nla_data (attr);
+	attr = info->attrs[LDT_CMD_BIND2DEV_ATTR_DEV];
+	if (!attr) return send_ret (net, pid, -EINVAL);
+	dev = (const char*)nla_data (attr);
+
+	tp_debug ("bind tunnel [%s] to dev %s", name, dev);
+	tdev = LDTDEV_BYNAME (net, name);
+	if (!tdev) {
+		tp_note ("cannot find device %s\n", name);
+		return send_ret (net, pid, -EINVAL);
+	}
+	tp_debug2 ("call ldt_dev_bind2dev\n");
+	ret = ldt_dev_bind2dev (tdev, dev);
+	dev_put (tdev->ndev);
+	tp_debug ("done -> %d\n", ret);
+	return send_ret (net, pid, ret);
+}
+
+static
+int
+ldt_nl_peer (skb, info)
+	struct sk_buff		*skb;
+	struct genl_info	*info;
+{
+	u32							pid, addr4;
+	u8								addr6[16];
+	u16							port;
+	tp_addr_t					raddr;
+	const struct nlmsghdr	*nlh;
+	const struct nlattr		*attr;
+	const char					*name;
+	struct net					*net;
+	int							ret;
+	struct ldt_dev		*tdev;
+	int							ipv6;
+	int							hasaddr;
+
+	if (!skb) return -EINVAL;
+	nlh = nlmsg_hdr(skb);
+	if (!nlh) return -EINVAL;
+	pid = nlh->nlmsg_pid;
+	if (!info) return -EINVAL;
+	net = genl_info_net (info);
+	if (!net) return -EINVAL;
+	attr = info->attrs[LDT_CMD_PEER_ATTR_NAME];
+	if (!attr) return send_ret (net, pid, -EINVAL);
+	name = (const char*)nla_data (attr);
+	attr = info->attrs[LDT_CMD_PEER_ATTR_ADDR4];
+	if (attr) {
+		addr4 = nla_get_u32 (attr);
+		ipv6 = 0;
+	} else {
+		attr = info->attrs[LDT_CMD_PEER_ATTR_ADDR6];
+		if (attr) {
+			if (nla_len(attr) != 16) return send_ret (net, pid, -EINVAL);
+			memcpy (addr6, nla_data (attr), 16);
+			ipv6 = 1;
+		}
+	}
+	if (attr) {
+		attr = info->attrs[LDT_CMD_PEER_ATTR_PORT];
+		if (!attr) return send_ret (net, pid, -EINVAL);
+		port = nla_get_u16 (attr);
+		if (!ipv6) {
+			tp_addr_setipv4 (&raddr, addr4, port);
+		} else {
+			tp_addr_setipv6 (&raddr, addr6, port);
+		}
+		hasaddr = 1;
+	} else {
+		hasaddr = 0;
+	}
+	tp_debug ("tunnel [%s] peer is %pISc\n", name, &raddr);
+	tdev = LDTDEV_BYNAME (net, name);
+	if (!tdev) return send_ret (net, pid, -EINVAL);
+	ret = ldt_dev_peer (tdev, hasaddr ? &raddr : NULL);
+	dev_put (tdev->ndev);
+	return send_ret (net, pid, ret);
+}
+
+static
+int
+ldt_nl_serverstart (skb, info)
+	struct sk_buff		*skb;
+	struct genl_info	*info;
+{
+	u32							pid;
+	const struct nlmsghdr	*nlh;
+	const struct nlattr		*attr;
+	const char					*name;
+	struct net					*net;
+	int							ret;
+	struct ldt_dev		*tdev;
+
+	if (!skb) return -EINVAL;
+	nlh = nlmsg_hdr(skb);
+	if (!nlh) return -EINVAL;
+	pid = nlh->nlmsg_pid;
+	if (!info) return -EINVAL;
+	net = genl_info_net (info);
+	if (!net) return -EINVAL;
+	attr = info->attrs[LDT_CMD_SERVERSTART_ATTR_NAME];
+	if (!attr) return send_ret (net, pid, -EINVAL);
+	name = (const char*)nla_data (attr);
+	tp_debug ("start server [%s]\n", name);
+	tdev = LDTDEV_BYNAME (net, name);
+	if (!tdev) return send_ret (net, pid, -EINVAL);
+	ret = ldt_dev_serverstart (tdev);
+	dev_put (tdev->ndev);
+	return send_ret (net, pid, ret);
+}
+
+
+static
+int
+ldt_nl_set_mtu (skb, info)
+	struct sk_buff		*skb;
+	struct genl_info	*info;
+{
+	const char					*name;
+	u32							pid;
+	const struct nlmsghdr	*nlh;
+	const struct nlattr		*attr;
+	struct net					*net;
+	u32							mtu;
+	int							ret;
+	struct ldt_dev		*tdev;
+
+	if (!skb) return -EINVAL;
+	if (!info) return -EINVAL;
+	nlh = nlmsg_hdr(skb);
+	if (!nlh) return -EINVAL;
+	pid = nlh->nlmsg_pid;
+	net = genl_info_net (info);
+	if (!net) return -EINVAL;
+	attr = info->attrs[LDT_CMD_SET_MTU_ATTR_NAME];
+	if (!attr) return send_ret (net, pid, -EINVAL);
+	name = (const char*)nla_data (attr);
+	attr = info->attrs[LDT_CMD_SET_MTU_ATTR_MTU];
+	if (!attr) return send_ret (net, pid, -EINVAL);
+	mtu = nla_get_u32 (attr);
+	tp_debug ("set mtu on device %s\n", name?name:"???");
+	tdev = LDTDEV_BYNAME (net, name);
+	if (!tdev) return send_ret (net, pid, -EINVAL);
+	ret = ldt_dev_set_mtu (tdev, mtu);
+	dev_put (tdev->ndev);
+	return send_ret (net, pid, ret);
+}
+
+static
+int
+ldt_nl_set_queue (skb, info)
+	struct sk_buff		*skb;
+	struct genl_info	*info;
+{
+	const char					*name;
+	u32							pid;
+	int							txqlen;
+	int							qpolicy;
+	const struct nlmsghdr	*nlh;
+	const struct nlattr		*attr;
+	struct net					*net;
+	struct ldt_dev		*tdev;
+	int							ret;
+
+	if (!skb) return -EINVAL;
+	if (!info) return -EINVAL;
+	nlh = nlmsg_hdr(skb);
+	if (!nlh) return -EINVAL;
+	pid = nlh->nlmsg_pid;
+	net = genl_info_net (info);
+	if (!net) return -EINVAL;
+	attr = info->attrs[LDT_CMD_SETQUEUE_ATTR_NAME];
+	if (!attr) return send_ret (net, pid, -EINVAL);
+	name = (const char*)nla_data (attr);
+	attr = info->attrs[LDT_CMD_SETQUEUE_ATTR_TXQLEN];
+	if (!attr) {
+		txqlen = -1;
+	} else {
+		txqlen = (int)(unsigned)nla_get_u16 (attr);
+	}
+	attr = info->attrs[LDT_CMD_SETQUEUE_ATTR_QPOLICY];
+	if (!attr) {
+		qpolicy = -1;
+	} else {
+		qpolicy = (int)(unsigned)nla_get_u16 (attr);
+		if (qpolicy > LDT_CMD_SETQUEUE_QPOLICY_MAX) {
+			tp_note ("invalid queueing policy %d\n", qpolicy);
+			return send_ret (net, pid, -ERANGE);
+		}
+	}
+	tp_debug ("set queue (txqlen = %d, qpolicy = %d)", txqlen, qpolicy);
+	tdev = LDTDEV_BYNAME (net, name);
+	if (!tdev) return send_ret (net, pid, -EINVAL);
+	ret = ldt_dev_setqueue (tdev, txqlen, qpolicy);
+	dev_put (tdev->ndev);
+	return send_ret (net, pid, ret);
+}
+
+
+static
+int
+ldt_nl_evsend (skb, info)
+	struct sk_buff		*skb;
+	struct genl_info	*info;
+{
+	const char					*name;
+	u32							pid;
+	const struct nlmsghdr	*nlh;
+	const struct nlattr		*attr;
+	struct net					*net;
+	int							ret;
+	struct ldt_dev		*tdev;
+	u32							reason;
+	u32							evtype;
+
+	if (!skb) return -EINVAL;
+	if (!info) return -EINVAL;
+	nlh = nlmsg_hdr(skb);
+	if (!nlh) return -EINVAL;
+	pid = nlh->nlmsg_pid;
+	net = genl_info_net (info);
+	if (!net) return -EINVAL;
+	attr = info->attrs[LDT_CMD_EVSEND_ATTR_NAME];
+	if (!attr) return send_ret (net, pid, -EINVAL);
+	name = (const char*)nla_data (attr);
+	attr = info->attrs[LDT_CMD_EVSEND_ATTR_EVTYPE];
+	if (!attr) return send_ret (net, pid, -EINVAL);
+	evtype = nla_get_u32 (attr);
+	attr = info->attrs[LDT_CMD_EVSEND_ATTR_REASON];
+	if (!attr) return send_ret (net, pid, -EINVAL);
+	reason = nla_get_u32 (attr);
+	tp_debug ("send event %d for device %s\n",
+					evtype, name?name:"???");
+	tdev = LDTDEV_BYNAME (net, name);
+	if (!tdev) return send_ret (net, pid, -EINVAL);
+	ret = ldt_dev_evsend (tdev, evtype, reason);
+	dev_put (tdev->ndev);
+	return send_ret (net, pid, ret);
+}
+
+
+
+static
+int
+ldt_nl_subscribe (skb, info)
+	struct sk_buff		*skb;
+	struct genl_info	*info;
+{
+	u32							pid;
+	const struct nlmsghdr	*nlh;
+	struct net					*net;
+	int							ret;
+
+	if (!skb) return -EINVAL;
+	if (!info) return -EINVAL;
+	nlh = nlmsg_hdr(skb);
+	if (!nlh) return -EINVAL;
+	pid = nlh->nlmsg_pid;
+	net = genl_info_net (info);
+	if (!net) return -EINVAL;
+	tp_debug ("got event subscription");
+	ret = ldt_nl_adduser (pid, net);
+	return send_ret (net, pid, ret);
+}
+
+
+static
+int
+ldt_nl_release_notifier (nb, action, data)
+	struct notifier_block	*nb;
+	unsigned long				action;
+	void							*data;
+{
+	struct netlink_notify	*n = data;
+
+	if (n && action==NETLINK_URELEASE) {
+		ldt_nl_rmuser (n->portid, n->net);
+	}
+	return NOTIFY_DONE;
+}
+
+static
+int
+send_ret (net, pid, rval)
+	struct net	*net;
+	u32			pid;
+	int			rval;
+{
+	int	ret;
+
+	tp_debug ("send return value: %d to %d\n", rval, (int) pid);
+	if (rval != 0) {
+		/* don't really send it */
+		return rval;
+	}
+	ret = send_info (net, pid, rval, NULL, 0);
+	if (ret < 0) {
+		tp_err ("error sending return value (%d) to %d: %d\n",
+					rval, (int)pid, ret);
+		return ret;
+	}
+	return rval;
+}
+
+static int ldt_sndinfo_seq = 0;
+static
+int
+send_info (net, pid, rval, data, len)
+	struct net	*net;
+	u32			pid;
+	const char	*data;
+	u32			len;
+	int			rval;
+{
+	struct sk_buff *skb;
+	void				*p;
+	int				ret, num;
+	u32				xval;
+	const char		*s;
+
+#define CHUNKSZ	4096
+	if (!net) return -EINVAL;
+	tp_debug ("send data to %d\n", (int)pid);
+	if (!len && data) len = strlen (data) + 1;
+	if (!data) len = 0;
+	skb = genlmsg_new (len+(len/CHUNKSZ*4)+128, GFP_KERNEL);
+	if (!skb) return -ENOMEM;
+	/* create the message headers */
+	p = genlmsg_put (	skb, pid, ldt_sndinfo_seq++, &ldt_nl_family,
+							/* flags = */ 0, LDT_CMD_SEND_INFO);
+	if (!p) {
+		nlmsg_free (skb);
+		tp_err ("error creating message\n");
+		return -ENOMEM;
+	}
+	/* add attribute */
+	xval = (rval < 0) ? (rval * (-1)) : rval;
+	ret = nla_put_u32 (skb, LDT_CMD_SEND_INFO_ATTR_RET, xval);
+	if (ret < 0) {
+		nlmsg_free (skb);
+		tp_err ("error creating message: %d\n", ret);
+		return ret;
+	}
+	if (data) {
+		s = data;
+		num=0;
+		while (len > CHUNKSZ) {
+			num++;
+			ret = nla_put (skb, LDT_CMD_SEND_INFO_ATTR_INFO, CHUNKSZ, s);
+			if (ret < 0) {
+				nlmsg_free (skb);
+				tp_err ("error creating message: %d\n", ret);
+				return ret;
+			}
+			s += CHUNKSZ;
+			len -= CHUNKSZ;
+		}
+		if (len > 0 || s == data) {
+			num++;
+			ret = nla_put (skb, LDT_CMD_SEND_INFO_ATTR_INFO, len, s);
+			if (ret < 0) {
+				nlmsg_free (skb);
+				tp_err ("error creating message: %d\n", ret);
+				return ret;
+			}
+		}
+		len += s-data;
+		tp_debug2 ("sent %d bytes of data in %d chunks of size %d\n",
+						(int)len, num, CHUNKSZ);
+	}
+	/* finalize message */
+	genlmsg_end (skb, p);
+
+	/* send message */
+	ret = genlmsg_unicast (net, skb, pid);
+	if (ret < 0) {
+		nlmsg_free (skb);
+		tp_err ("error sending message: %d\n", ret);
+		return ret;
+	}
+	return 0;
+}
+
+static
+int
+do_send_event (net, pid, evtype, iarg, sarg)
+	struct net	*net;
+	u32			pid;
+	u32			evtype;
+	u32			iarg;
+	const char	*sarg;
+{
+	struct sk_buff *skb;
+	void				*p;
+	int				ret, len;
+
+	if (!net) return -EINVAL;
+	tp_debug ("sending event (%d) to user %d\n", (int)evtype, pid);
+	len = sarg ? strlen (sarg)+1 : 0;
+	skb = genlmsg_new (len+128, GFP_KERNEL);
+	if (!skb) return -ENOMEM;
+	/* create the message headers */
+	p = genlmsg_put (	skb, pid, ldt_sndinfo_seq++, &ldt_nl_family,
+							/* flags = */ 0, LDT_CMD_SEND_EVENT);
+	if (!p) {
+		nlmsg_free (skb);
+		tp_err ("error creating message\n");
+		return -ENOMEM;
+	}
+	/* add attribute */
+	ret = nla_put_u32 (skb, LDT_CMD_SEND_EVENT_ATTR_EVTYPE, evtype);
+	if (ret < 0) {
+		nlmsg_free (skb);
+		tp_err ("error creating message: %d\n", ret);
+		return ret;
+	}
+	ret = nla_put_u32 (skb, LDT_CMD_SEND_EVENT_ATTR_IARG, iarg);
+	if (ret < 0) {
+		nlmsg_free (skb);
+		tp_err ("error creating message: %d\n", ret);
+		return ret;
+	}
+	if (sarg) {
+		ret = nla_put (skb, LDT_CMD_SEND_EVENT_ATTR_SARG, len, sarg);
+		if (ret < 0) {
+			nlmsg_free (skb);
+			tp_err ("error creating message: %d\n", ret);
+			return ret;
+		}
+	}
+	/* finalize message */
+	genlmsg_end (skb, p);
+
+	/* send message */
+	tp_debug ("sendmsg");
+	ret = genlmsg_unicast (net, skb, pid);
+	if (ret < 0) {
+		nlmsg_free (skb);
+		tp_err ("error sending message: %d\n", ret);
+		return ret;
+	}
+	return 0;
+}
+
+
+int
+ldt_nl_send_event (net, evtype, iarg, sarg)
+	struct net	*net;
+	u32			evtype;
+	u32			iarg;
+	const char	*sarg;
+{
+	struct ldt_nl_user	*p;
+
+	tp_debug ("send event %d\n", evtype);
+	list_for_each_entry_rcu (p, &tpnl_head, list) {
+		tp_debug3 ("check user %d (valid==%d)\n", (int) p->pid, p->valid);
+		if (p->valid && (p->net == net || !net)) {
+			do_send_event (p->net, p->pid, evtype, iarg, sarg);
+		}
+	}
+	return 0;
+}
+
+
+/*
+ *	handle the list of users
+ */
+
+
+static
+int
+ldt_nl_adduser (pid, net)
+	u32			pid;
+	struct net	*net;
+{
+	struct ldt_nl_user	*user, *p;
+	struct list_head			delhead;
+
+	if (pid <= 0) return -EINVAL;
+	/* check wether user already exists */
+	list_for_each_entry_rcu (p, &tpnl_head, list) {
+		if (p->pid == pid && p->net == net) {
+			if (!p->valid) p->valid = 1;
+			return 0;
+		}
+	}
+
+	/* create new user */
+	user = kmalloc (sizeof (struct ldt_nl_user), GFP_KERNEL);
+	if (!user) return -ENOMEM;
+	*user = LDT_NL_USER_NULL;
+	INIT_LIST_HEAD (&(user->dellist));
+	user->valid = 1;
+	user->pid = pid;
+	user->net = net;
+
+	/* just a dummy list for elements to be deleted */
+	INIT_LIST_HEAD (&delhead);
+
+	G_LOCK;
+	/* add new user first */
+	list_add_rcu (&(user->list), &tpnl_head);
+	tp_debug ("add user %d\n", (int)pid);
+
+	/* now traverse the list for elements to be deleted */
+	list_for_each_entry_rcu (p, &tpnl_head, list) {
+		if (!p->valid) {
+			list_del_rcu (&(p->list));
+			list_add_rcu (&(p->dellist), &delhead);
+		}
+	}
+	G_UNLOCK;
+
+	/* now we are safe and can delete users in dellist */
+	list_for_each_entry_safe (user, p, &delhead, dellist) {
+		tp_debug ("delete user %d\n", (int)user->pid);
+		*user = LDT_NL_USER_NULL;
+		kfree (user);
+	}
+	return 0;
+}
+
+
+static
+void
+ldt_nl_rmuser (pid, net)
+	u32			pid;
+	struct net	*net;
+{
+	struct ldt_nl_user	*p;
+
+	list_for_each_entry_rcu (p, &tpnl_head, list) {
+		if (p->valid && (p->net == net || !net) && p->pid == pid) {
+			/* we don't realy delete here, this could create dead locks,
+			 * thus we only mark it to be deleted and delete it in next
+			 * add user call */
+			p->valid = 0;
+			tp_debug ("release user %d\n", (int)pid);
+		}
+	}
+}
+
+static
+void
+ldt_nl_rmalluser (void)
+{
+	struct ldt_nl_user	*user, *p;
+	struct list_head			delhead;
+
+	INIT_LIST_HEAD (&delhead);
+
+	/* first traverse the list and move elements to delhead */
+	G_LOCK;
+	list_for_each_entry_rcu (p, &tpnl_head, list) {
+		list_del_rcu (&(p->list));
+		list_add_rcu (&(p->dellist), &delhead);
+	}
+	G_UNLOCK;
+
+	/* now we are safe and can delete users in dellist */
+
+	list_for_each_entry_safe (user, p, &delhead, dellist) {
+		*user = LDT_NL_USER_NULL;
+		kfree (user);
+	}
+}
+
+
+
+
+
+
+
+
+
+/*
+ * Overrides for XEmacs and vim so that we get a uniform tabbing style.
+ * XEmacs/vim will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 3
+ * c-basic-offset: 3
+ * tab-width: 3
+ * End:
+ * vim:tw=0:ts=3:wm=0:
+ */
diff --git a/net/ldt/ldt_netlink.h b/net/ldt/ldt_netlink.h
new file mode 100644
index 0000000000000..027e5609d5f2d
--- /dev/null
+++ b/net/ldt/ldt_netlink.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2015-2022 by Frank Reker, Deutsche Telekom AG
+ *
+ * LDT - Lightweight (MP-)DCCP Tunnel kernel module
+ *
+ * This is not Open Source software.
+ * This work is made available to you under a source-available license, as
+ * detailed below.
+ *
+ * Copyright 2022 Deutsche Telekom AG
+ *
+ * Permission is hereby granted, free of charge, subject to below Commons
+ * Clause, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * “Commons Clause” License Condition v1.0
+ *
+ * The Software is provided to you by the Licensor under the License, as
+ * defined below, subject to the following condition.
+ *
+ * Without limiting other conditions in the License, the grant of rights under
+ * the License will not include, and the License does not grant to you, the
+ * right to Sell the Software.
+ *
+ * For purposes of the foregoing, “Sell” means practicing any or all of the
+ * rights granted to you under the License to provide to third parties, for a
+ * fee or other consideration (including without limitation fees for hosting
+ * or consulting/ support services related to the Software), a product or
+ * service whose value derives, entirely or substantially, from the
+ * functionality of the Software. Any license notice or attribution required
+ * by the License must also include this Commons Clause License Condition
+ * notice.
+ *
+ * Licensor: Deutsche Telekom AG
+ */
+
+#ifndef _R__KERNEL_LDT_NL_INT_H
+#define _R__KERNEL_LDT_NL_INT_H
+
+
+struct net;
+int ldt_nl_send_event (struct net *net, u32 evtype, u32 iarg, const char *sarg);
+
+int ldt_nl_register (void);
+void ldt_nl_unregister (void);
+
+
+extern int ldt_nl_family_id;
+
+
+
+
+
+
+#endif	/* _R__KERNEL_LDT_NL_INT_H */
+
+/*
+ * Overrides for XEmacs and vim so that we get a uniform tabbing style.
+ * XEmacs/vim will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 3
+ * c-basic-offset: 3
+ * tab-width: 3
+ * End:
+ * vim:tw=0:ts=3:wm=0:
+ */
diff --git a/net/ldt/ldt_prot1.c b/net/ldt/ldt_prot1.c
new file mode 100644
index 0000000000000..2df03c05e0953
--- /dev/null
+++ b/net/ldt/ldt_prot1.c
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2015-2022 by Frank Reker, Deutsche Telekom AG
+ *
+ * LDT - Lightweight (MP-)DCCP Tunnel kernel module
+ *
+ * This is not Open Source software.
+ * This work is made available to you under a source-available license, as
+ * detailed below.
+ *
+ * Copyright 2022 Deutsche Telekom AG
+ *
+ * Permission is hereby granted, free of charge, subject to below Commons
+ * Clause, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * “Commons Clause” License Condition v1.0
+ *
+ * The Software is provided to you by the Licensor under the License, as
+ * defined below, subject to the following condition.
+ *
+ * Without limiting other conditions in the License, the grant of rights under
+ * the License will not include, and the License does not grant to you, the
+ * right to Sell the Software.
+ *
+ * For purposes of the foregoing, “Sell” means practicing any or all of the
+ * rights granted to you under the License to provide to third parties, for a
+ * fee or other consideration (including without limitation fees for hosting
+ * or consulting/ support services related to the Software), a product or
+ * service whose value derives, entirely or substantially, from the
+ * functionality of the Software. Any license notice or attribution required
+ * by the License must also include this Commons Clause License Condition
+ * notice.
+ *
+ * Licensor: Deutsche Telekom AG
+ */
+
+
+
+#include <linux/skbuff.h>
+#include <linux/notifier.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/netdevice.h>
+#include <linux/err.h>
+
+#include "ldt_dev.h"
+#include "ldt_tun.h"
+#include "ldt_uapi.h"
+#include "ldt_prot1.h"
+#include "ldt_debug.h"
+
+static int tp_prot1_recv (struct ldt_tun*, char*, int);
+
+
+int
+ldt_prot1_recv (tun, skb)
+	struct ldt_tun	*tun;
+	struct sk_buff			*skb;
+{
+	int	ret;
+
+	ret = tp_prot1_recv (tun, skb->data, skb->len);
+	kfree_skb (skb);
+	if (ret < 0) {
+		tp_debug ("error receiving prot 1 packet: %d\n", ret);
+		return ret;
+	}
+	return 0;
+}
+
+
+static
+int
+tp_prot1_recv (tun, data, len)
+	struct ldt_tun	*tun;
+	char						*data;
+	int						len;
+{
+	int	xlen, type;
+
+	if (!tun || !data) return -EINVAL;
+	if (len < 4) return -EBADMSG;
+	if (!TP_ISPROT1(data[0])) return -EBADMSG;
+	xlen = ((u32)(u8)data[1]) * 4;
+	if (len < xlen) return -EBADMSG;
+	len = xlen;
+	type = (int)(u32)data[3];
+	tp_debug2 ("received prot 1 type %d msg\n", type);
+	switch (type) {
+	case TP_PROT1_T_KEEPALIVE:
+		break;
+	case TP_PROT1_T_SNDCFG:
+		break;
+	case TP_PROT1_T_FASTAUTH:
+		break;
+	case TP_PROT1_T_AUTHFAIL:
+		break;
+	/* ignore all other */
+	}
+	return 0;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+/*
+ * Overrides for XEmacs and vim so that we get a uniform tabbing style.
+ * XEmacs/vim will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 3
+ * c-basic-offset: 3
+ * tab-width: 3
+ * End:
+ * vim:tw=0:ts=3:wm=0:
+ */
diff --git a/net/ldt/ldt_prot1.h b/net/ldt/ldt_prot1.h
new file mode 100644
index 0000000000000..74f1aaf2f9c4a
--- /dev/null
+++ b/net/ldt/ldt_prot1.h
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2015-2022 by Frank Reker, Deutsche Telekom AG
+ *
+ * LDT - Lightweight (MP-)DCCP Tunnel kernel module
+ *
+ * This is not Open Source software.
+ * This work is made available to you under a source-available license, as
+ * detailed below.
+ *
+ * Copyright 2022 Deutsche Telekom AG
+ *
+ * Permission is hereby granted, free of charge, subject to below Commons
+ * Clause, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * “Commons Clause” License Condition v1.0
+ *
+ * The Software is provided to you by the Licensor under the License, as
+ * defined below, subject to the following condition.
+ *
+ * Without limiting other conditions in the License, the grant of rights under
+ * the License will not include, and the License does not grant to you, the
+ * right to Sell the Software.
+ *
+ * For purposes of the foregoing, “Sell” means practicing any or all of the
+ * rights granted to you under the License to provide to third parties, for a
+ * fee or other consideration (including without limitation fees for hosting
+ * or consulting/ support services related to the Software), a product or
+ * service whose value derives, entirely or substantially, from the
+ * functionality of the Software. Any license notice or attribution required
+ * by the License must also include this Commons Clause License Condition
+ * notice.
+ *
+ * Licensor: Deutsche Telekom AG
+ */
+
+#ifndef _R__KERNEL_LDT_PROT1_H
+#define _R__KERNEL_LDT_PROT1_H
+
+#include <linux/types.h>
+#include <linux/skbuff.h>
+
+#define TP_PROT1_T_KEEPALIVE	1
+#define TP_PROT1_T_HANDSHAKE	2
+#define TP_PROT1_T_SNDCFG		3
+#define TP_PROT1_T_FASTAUTH	4
+#define TP_PROT1_T_AUTHFAIL	5
+
+/* handshake subtypes */
+#define TP_HST_UDP	1
+
+/* send config subtypes */
+#define TP_SNDCFG_IP		1
+#define TP_SNDCFG_MPTCP	2
+#define TP_SNDCFG_UCFG	3
+
+/* fastauth subtypes */
+#define TP_FASTAUTH_REQ	1
+#define TP_FASTAUTH_ACK	2
+
+
+
+#define TP_GETPKTTYPE(data)	(((u8)(data))>>4)
+#define TP_ISPROT1(data)	(TP_GETPKTTYPE(data)==1)
+#define TP_PROT1GETTYPE(data,sz)	((!(data)||(sz)<4)?0:(data)[3])
+#define TP_PROT1GETSUBTYPE(data,sz)	((!(data)||(sz)<4)?0:(data)[2])
+#define TP_ISHANDSHAKE(data,sz)	((!(data)||(sz)<8)?0:((TP_ISPROT1((data)[0])\
+												&&((data)[3]==TP_PROT1_T_HANDSHAKE))?1:0))
+#define TP_ISAUTHFAIL(data,sz)	((!(data)||(sz)<8)?0:((TP_ISPROT1((data)[0])\
+												&&((data)[3]==TP_PROT1_T_AUTHFAIL))?1:0))
+#define TP_ISFASTAUTH(data,sz)	((!(data)||(sz)<12)?0:((TP_ISPROT1((data)[0])\
+												&&((data)[3]==TP_PROT1_T_FASTAUTH))?1:0))
+#define TP_SKBISPROT1(skb)	((skb)->data && (skb)->len>0 && TP_ISPROT1((skb)->data[0]))
+#define TP_SKBPROT1GETTYPE(skb)	(TP_PROT1GETTYPE((skb)->data,(skb)->len))
+#define TP_SKBPROT1GETSUBTYPE(skb)	(TP_PROT1GETSUBTYPE((skb)->data,(skb)->len))
+#define TP_SKBISHANDSHAKE(skb)	(TP_ISHANDSHAKE((skb)->data,(skb)->len))
+#define TP_SKBISFASTAUTH(skb)		(TP_ISFASTAUTH((skb)->data,(skb)->len))
+
+#define TP_PROT1_MAXSZ	1020	/* 255 << 2 */
+
+static inline int ldt_prot1msglen (char *data, int sz)
+{
+	if (!data || sz < 4) return -EBADMSG;
+	if (!TP_ISPROT1(data[0])) return -EBADMSG;
+	return ((u32)(u8)(data[1])) << 2;
+}
+
+struct ldt_tun;
+int ldt_prot1_recv (struct ldt_tun *tun, struct sk_buff *skb);
+
+
+
+
+
+#endif	/* _R__KERNEL_LDT_PROT1_H */
+
+
+/*
+ * Overrides for XEmacs and vim so that we get a uniform tabbing style.
+ * XEmacs/vim will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 3
+ * c-basic-offset: 3
+ * tab-width: 3
+ * End:
+ * vim:tw=0:ts=3:wm=0:
+ */
diff --git a/net/ldt/ldt_queue.c b/net/ldt/ldt_queue.c
new file mode 100644
index 0000000000000..f5b3615b55848
--- /dev/null
+++ b/net/ldt/ldt_queue.c
@@ -0,0 +1,303 @@
+/*
+ * Copyright (C) 2015-2022 by Frank Reker, Deutsche Telekom AG
+ *
+ * LDT - Lightweight (MP-)DCCP Tunnel kernel module
+ *
+ * This is not Open Source software.
+ * This work is made available to you under a source-available license, as
+ * detailed below.
+ *
+ * Copyright 2022 Deutsche Telekom AG
+ *
+ * Permission is hereby granted, free of charge, subject to below Commons
+ * Clause, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * “Commons Clause” License Condition v1.0
+ *
+ * The Software is provided to you by the Licensor under the License, as
+ * defined below, subject to the following condition.
+ *
+ * Without limiting other conditions in the License, the grant of rights under
+ * the License will not include, and the License does not grant to you, the
+ * right to Sell the Software.
+ *
+ * For purposes of the foregoing, “Sell” means practicing any or all of the
+ * rights granted to you under the License to provide to third parties, for a
+ * fee or other consideration (including without limitation fees for hosting
+ * or consulting/ support services related to the Software), a product or
+ * service whose value derives, entirely or substantially, from the
+ * functionality of the Software. Any license notice or attribution required
+ * by the License must also include this Commons Clause License Condition
+ * notice.
+ *
+ * Licensor: Deutsche Telekom AG
+ */
+
+#include <linux/skbuff.h>
+//#include <linux/lockdep.h>
+#include "ldt_queue.h"
+
+
+
+//static struct lock_class_key	lock_key;
+
+struct tp_queue_ops {
+	void					(*enqueue) (struct tp_queue*, struct sk_buff*);
+	struct sk_buff*	(*dequeue) (struct tp_queue*);
+	void					(*requeue) (struct tp_queue*, struct sk_buff*);
+	int					(*isfull)  (struct tp_queue*);
+};
+
+static void tpq_inf_enqueue (struct tp_queue*, struct sk_buff*);
+static struct sk_buff* tpq_inf_dequeue (struct tp_queue*);
+static void tpq_inf_requeue (struct tp_queue*, struct sk_buff*);
+static int tpq_limit_isfull (struct tp_queue*);
+static void tpq_drop_oldest_enqueue (struct tp_queue*, struct sk_buff*);
+static void tpq_drop_newest_enqueue (struct tp_queue*, struct sk_buff*);
+
+
+static struct tp_queue_ops queue_tbl[TP_QUEUE_MAX+1] = {
+	[TP_QUEUE_INF] = {
+		.enqueue = tpq_inf_enqueue,
+		.dequeue = tpq_inf_dequeue,
+		.requeue = tpq_inf_requeue,
+		.isfull = NULL,
+	},
+	[TP_QUEUE_LIMIT] = {
+		.enqueue = tpq_inf_enqueue,
+		.dequeue = tpq_inf_dequeue,
+		.requeue = tpq_inf_requeue,
+		.isfull = tpq_limit_isfull,
+	},
+	[TP_QUEUE_DROP_OLDEST] = {
+		.enqueue = tpq_drop_oldest_enqueue,
+		.dequeue = tpq_inf_dequeue,
+		.requeue = tpq_inf_requeue,
+		.isfull = NULL,
+	},
+	[TP_QUEUE_DROP_NEWEST] = {
+		.enqueue = tpq_drop_newest_enqueue,
+		.dequeue = tpq_inf_dequeue,
+		.requeue = tpq_inf_requeue,
+		.isfull = NULL,
+	},
+};
+
+
+void
+tpq_init (queue, policy, maxlen)
+	struct tp_queue	*queue;
+	int					policy;
+	int					maxlen;
+{
+	if (!queue) return;
+	*queue = (struct tp_queue) { .q_maxlen = 1 };
+	skb_queue_head_init(&queue->queue);
+#if 0
+	lockdep_set_class_and_name(&queue->queue.lock,
+								&lock_key, "tp_xmit_lock");
+#endif
+	tpq_set_policy (queue, policy);
+	tpq_set_maxlen (queue, maxlen);
+}
+
+void
+tpq_set_policy (queue, policy)
+	struct tp_queue	*queue;
+	int					policy;
+{
+	if (!queue) return;
+	if (policy < 0 || policy > TP_QUEUE_MAX) return;
+	queue->policy = policy;
+}
+
+void
+tpq_set_maxlen (queue, maxlen)
+	struct tp_queue	*queue;
+	int					maxlen;
+{
+	if (!queue) return;
+	if (maxlen < 1) return;
+	queue->q_maxlen = maxlen;
+}
+
+void
+tpq_destroy (queue)
+	struct tp_queue	*queue;
+{
+	struct sk_buff	*skb;
+
+	if (!queue) return;
+	while ((skb = tpq_inf_dequeue (queue))) {
+		kfree (skb);
+	}
+	*queue = (struct tp_queue) { .q_maxlen = 0 };
+}
+
+
+void
+tpq_enqueue (queue, skb)
+	struct tp_queue	*queue;
+	struct sk_buff		*skb;
+{
+	if (!queue || !skb || (unsigned) queue->policy > TP_QUEUE_MAX) return;
+	if (!queue_tbl[queue->policy].enqueue) return;
+	queue_tbl[queue->policy].enqueue (queue, skb);
+}
+
+struct sk_buff*
+tpq_dequeue (queue)
+	struct tp_queue	*queue;
+{
+	if (!queue || (unsigned) queue->policy > TP_QUEUE_MAX) return NULL;
+	if (!queue_tbl[queue->policy].dequeue) return NULL;
+	return queue_tbl[queue->policy].dequeue (queue);
+}
+
+void
+tpq_requeue (queue, skb)
+	struct tp_queue	*queue;
+	struct sk_buff		*skb;
+{
+	if (!queue || !skb || (unsigned) queue->policy > TP_QUEUE_MAX) return;
+	if (!queue_tbl[queue->policy].requeue) return;
+	queue_tbl[queue->policy].requeue (queue, skb);
+}
+
+int
+tpq_isfull (queue)
+	struct tp_queue	*queue;
+{
+	if (!queue || (unsigned) queue->policy > TP_QUEUE_MAX) return 0;
+	if (!queue_tbl[queue->policy].isfull) return 0;
+	return queue_tbl[queue->policy].isfull (queue);
+}
+
+
+
+
+
+/*
+ * infinity queue
+ */
+
+static
+void
+tpq_inf_enqueue (queue, skb)
+	struct tp_queue	*queue;
+	struct sk_buff		*skb;
+{
+	skb_queue_head (&queue->queue, skb);
+}
+
+static
+struct sk_buff*
+tpq_inf_dequeue (queue)
+	struct tp_queue	*queue;
+{
+	struct sk_buff	*skb;
+
+	skb = skb_peek_tail (&queue->queue);
+	if (skb) skb_unlink (skb, &queue->queue);
+	return skb;
+}
+
+static
+void
+tpq_inf_requeue (queue, skb)
+	struct tp_queue	*queue;
+	struct sk_buff		*skb;
+{
+	skb_queue_tail(&queue->queue, skb);
+}
+
+
+/*
+ * limited queue
+ */
+
+static
+int
+tpq_limit_isfull (queue)
+	struct tp_queue	*queue;
+{
+	return queue->queue.qlen >= queue->q_maxlen;
+}
+
+
+/*
+ * drop oldest queue
+ */
+
+static
+void
+tpq_drop_oldest_enqueue (queue, skb)
+	struct tp_queue	*queue;
+	struct sk_buff		*skb;
+{
+	struct sk_buff	*oskb;
+
+	if (tpq_limit_isfull (queue)) {
+		oskb = tpq_inf_dequeue (queue);
+		if (oskb) {
+			kfree_skb (oskb);
+		}
+	}
+	tpq_inf_enqueue (queue, skb);
+}
+
+
+/*
+ * drop newest queue
+ */
+
+static
+void
+tpq_drop_newest_enqueue (queue, skb)
+	struct tp_queue	*queue;
+	struct sk_buff		*skb;
+{
+	if (tpq_limit_isfull (queue)) {
+		kfree_skb (skb);
+	} else {
+		tpq_inf_enqueue (queue, skb);
+	}
+}
+
+
+
+
+
+
+
+
+
+/*
+ * Overrides for XEmacs and vim so that we get a uniform tabbing style.
+ * XEmacs/vim will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 3
+ * c-basic-offset: 3
+ * tab-width: 3
+ * End:
+ * vim:tw=0:ts=3:wm=0:
+ */
diff --git a/net/ldt/ldt_queue.h b/net/ldt/ldt_queue.h
new file mode 100644
index 0000000000000..fe9b5ec8a2b4d
--- /dev/null
+++ b/net/ldt/ldt_queue.h
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2015-2022 by Frank Reker, Deutsche Telekom AG
+ *
+ * LDT - Lightweight (MP-)DCCP Tunnel kernel module
+ *
+ * This is not Open Source software.
+ * This work is made available to you under a source-available license, as
+ * detailed below.
+ *
+ * Copyright 2022 Deutsche Telekom AG
+ *
+ * Permission is hereby granted, free of charge, subject to below Commons
+ * Clause, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * “Commons Clause” License Condition v1.0
+ *
+ * The Software is provided to you by the Licensor under the License, as
+ * defined below, subject to the following condition.
+ *
+ * Without limiting other conditions in the License, the grant of rights under
+ * the License will not include, and the License does not grant to you, the
+ * right to Sell the Software.
+ *
+ * For purposes of the foregoing, “Sell” means practicing any or all of the
+ * rights granted to you under the License to provide to third parties, for a
+ * fee or other consideration (including without limitation fees for hosting
+ * or consulting/ support services related to the Software), a product or
+ * service whose value derives, entirely or substantially, from the
+ * functionality of the Software. Any license notice or attribution required
+ * by the License must also include this Commons Clause License Condition
+ * notice.
+ *
+ * Licensor: Deutsche Telekom AG
+ */
+
+
+#ifndef _R__KERNEL_LDT_QUEUE_INT_H
+#define _R__KERNEL_LDT_QUEUE_INT_H
+
+#include <linux/skbuff.h>
+
+
+struct tp_queue {
+	struct sk_buff_head		queue;
+	int							q_maxlen;
+	int							policy;
+};
+
+
+#define TP_QUEUE_INF				0
+#define TP_QUEUE_LIMIT			1
+#define TP_QUEUE_DROP_OLDEST	2
+#define TP_QUEUE_DROP_NEWEST	3
+#define TP_QUEUE_MAX				3
+
+
+void tpq_init (struct tp_queue*, int policy, int maxlen);
+void tpq_destroy (struct tp_queue*);
+void tpq_set_policy (struct tp_queue*, int policy);
+void tpq_set_maxlen (struct tp_queue*, int maxlen);
+
+void tpq_enqueue (struct tp_queue*, struct sk_buff*);
+struct sk_buff* tpq_dequeue (struct tp_queue*);
+void tpq_requeue (struct tp_queue*, struct sk_buff*);
+int tpq_isfull (struct tp_queue*);
+
+
+
+
+
+
+#endif	/* _R__KERNEL_LDT_QUEUE_INT_H */
+
+/*
+ * Overrides for XEmacs and vim so that we get a uniform tabbing style.
+ * XEmacs/vim will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 3
+ * c-basic-offset: 3
+ * tab-width: 3
+ * End:
+ * vim:tw=0:ts=3:wm=0:
+ */
diff --git a/net/ldt/ldt_sysctl.c b/net/ldt/ldt_sysctl.c
new file mode 100644
index 0000000000000..5d180fdaf76a3
--- /dev/null
+++ b/net/ldt/ldt_sysctl.c
@@ -0,0 +1,207 @@
+/*
+ * Copyright (C) 2015-2022 by Frank Reker, Deutsche Telekom AG
+ *
+ * LDT - Lightweight (MP-)DCCP Tunnel kernel module
+ *
+ * This is not Open Source software.
+ * This work is made available to you under a source-available license, as
+ * detailed below.
+ *
+ * Copyright 2022 Deutsche Telekom AG
+ *
+ * Permission is hereby granted, free of charge, subject to below Commons
+ * Clause, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * “Commons Clause” License Condition v1.0
+ *
+ * The Software is provided to you by the Licensor under the License, as
+ * defined below, subject to the following condition.
+ *
+ * Without limiting other conditions in the License, the grant of rights under
+ * the License will not include, and the License does not grant to you, the
+ * right to Sell the Software.
+ *
+ * For purposes of the foregoing, “Sell” means practicing any or all of the
+ * rights granted to you under the License to provide to third parties, for a
+ * fee or other consideration (including without limitation fees for hosting
+ * or consulting/ support services related to the Software), a product or
+ * service whose value derives, entirely or substantially, from the
+ * functionality of the Software. Any license notice or attribution required
+ * by the License must also include this Commons Clause License Condition
+ * notice.
+ *
+ * Licensor: Deutsche Telekom AG
+ */
+
+
+#include <linux/kernel.h>
+#include <linux/sysctl.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+
+#include "ldt_sysctl.h"
+
+unsigned int tp_cfg_enable_debug = 0;
+unsigned int tp_cfg_show_key = 0;
+unsigned int tp_cfg_loglevel = 5;
+unsigned int tp_cfg_logflags = TP_CFG_LOG_F_RATELIMIT | TP_CFG_LOG_F_PRTFILE;
+
+
+static unsigned i_0 = 0;
+static unsigned i_1 = 1;
+static unsigned i_3 = 3;
+static unsigned i_9 = 9;
+
+static unsigned old_loglevel = 5;
+
+static
+int
+proc_loglevel (
+	struct ctl_table	*ctl,
+	int					write,
+	void __user			*buffer,
+	size_t				*lenp,
+	loff_t				*ppos)
+{
+	unsigned				val;
+	struct ctl_table	tbl = {
+										.data = &val,
+										.maxlen = sizeof (unsigned),
+										.extra1 = &i_0,
+										.extra2 = &i_9,
+									};
+	int					ret;
+
+	val = tp_cfg_loglevel;
+	ret = proc_dointvec_minmax (&tbl, write, buffer, lenp, ppos);
+	if (write && ret == 0) {
+		old_loglevel = tp_cfg_loglevel;
+		tp_cfg_loglevel = val;
+		tp_cfg_enable_debug = (val >= 7) ? val - 6 : 0;
+	}
+	return ret;
+}
+
+static
+int
+proc_debug (
+	struct ctl_table	*ctl,
+	int					write,
+	void __user			*buffer,
+	size_t				*lenp,
+	loff_t				*ppos)
+{
+	unsigned				val;
+	struct ctl_table	tbl = {
+										.data = &val,
+										.maxlen = sizeof (unsigned),
+										.extra1 = &i_0,
+										.extra2 = &i_3,
+									};
+	int					ret;
+
+	val = tp_cfg_enable_debug;
+	ret = proc_dointvec_minmax (&tbl, write, buffer, lenp, ppos);
+	if (write && ret == 0) {
+		tp_cfg_enable_debug = val;
+		tp_cfg_loglevel = (val > 0) ? val + 6 : old_loglevel;
+	}
+	return ret;
+}
+
+
+static struct ctl_table net_ldt_table[] = {
+	{
+		.procname       = "debug",
+		.data           = &tp_cfg_enable_debug,
+		.maxlen         = sizeof(unsigned int),
+		.mode           = 0644,
+		.proc_handler   = proc_debug,
+		.extra1			 = &i_0,
+		.extra2			 = &i_3,
+	},
+	{
+		.procname       = "loglevel",
+		.data           = &tp_cfg_loglevel,
+		.maxlen         = sizeof(unsigned int),
+		.mode           = 0644,
+		.proc_handler   = proc_loglevel,
+		.extra1			 = &i_0,
+		.extra2			 = &i_9,
+	},
+	{
+		.procname       = "logflags",
+		.data           = &tp_cfg_logflags,
+		.maxlen         = sizeof(unsigned int),
+		.mode           = 0644,
+		.proc_handler   = proc_dointvec_minmax,
+	},
+	{
+		.procname       = "show_key",
+		.data           = &tp_cfg_show_key,
+		.maxlen         = sizeof(unsigned int),
+		.mode           = 0644,
+		.proc_handler   = proc_dointvec_minmax,
+		.extra1			 = &i_0,
+		.extra2			 = &i_1,
+	},
+	{ }
+};
+
+
+static struct ctl_table_header	*sysctl_hdr = NULL;
+
+int
+ldt_sysctl_init (void)
+{
+	sysctl_hdr = register_sysctl("net/ldt", net_ldt_table);
+	if (!sysctl_hdr) return -ENOMEM;
+	return 0;
+}
+
+
+void
+ldt_sysctl_exit (void)
+{
+	if (sysctl_hdr) unregister_sysctl_table (sysctl_hdr);
+	sysctl_hdr = NULL;
+}
+
+
+
+
+
+
+
+
+
+
+/*
+ * Overrides for XEmacs and vim so that we get a uniform tabbing style.
+ * XEmacs/vim will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 3
+ * c-basic-offset: 3
+ * tab-width: 3
+ * End:
+ * vim:tw=0:ts=3:wm=0:
+ */
diff --git a/net/ldt/ldt_sysctl.h b/net/ldt/ldt_sysctl.h
new file mode 100644
index 0000000000000..254ac9d577351
--- /dev/null
+++ b/net/ldt/ldt_sysctl.h
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2015-2022 by Frank Reker, Deutsche Telekom AG
+ *
+ * LDT - Lightweight (MP-)DCCP Tunnel kernel module
+ *
+ * This is not Open Source software.
+ * This work is made available to you under a source-available license, as
+ * detailed below.
+ *
+ * Copyright 2022 Deutsche Telekom AG
+ *
+ * Permission is hereby granted, free of charge, subject to below Commons
+ * Clause, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * “Commons Clause” License Condition v1.0
+ *
+ * The Software is provided to you by the Licensor under the License, as
+ * defined below, subject to the following condition.
+ *
+ * Without limiting other conditions in the License, the grant of rights under
+ * the License will not include, and the License does not grant to you, the
+ * right to Sell the Software.
+ *
+ * For purposes of the foregoing, “Sell” means practicing any or all of the
+ * rights granted to you under the License to provide to third parties, for a
+ * fee or other consideration (including without limitation fees for hosting
+ * or consulting/ support services related to the Software), a product or
+ * service whose value derives, entirely or substantially, from the
+ * functionality of the Software. Any license notice or attribution required
+ * by the License must also include this Commons Clause License Condition
+ * notice.
+ *
+ * Licensor: Deutsche Telekom AG
+ */
+
+#ifndef _R__KERNEL_LDT_SYSCTL_H
+#define _R__KERNEL_LDT_SYSCTL_H
+
+
+extern unsigned int tp_cfg_enable_debug;
+extern unsigned int tp_cfg_show_key;
+extern unsigned int tp_cfg_loglevel;
+extern unsigned int tp_cfg_logflags;
+
+#define TP_CFG_LOG_F_PRTFILE     0x01
+#define TP_CFG_LOG_F_RATELIMIT   0x02
+
+
+
+int ldt_sysctl_init (void);
+void ldt_sysctl_exit (void);
+
+
+
+
+
+
+
+#endif	/* _R__KERNEL_LDT_SYSCTL_H */
+
+
+/*
+ * Overrides for XEmacs and vim so that we get a uniform tabbing style.
+ * XEmacs/vim will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 3
+ * c-basic-offset: 3
+ * tab-width: 3
+ * End:
+ * vim:tw=0:ts=3:wm=0:
+ */
diff --git a/net/ldt/ldt_tun.c b/net/ldt/ldt_tun.c
new file mode 100644
index 0000000000000..3a75ae2532b3f
--- /dev/null
+++ b/net/ldt/ldt_tun.c
@@ -0,0 +1,422 @@
+/*
+ * Copyright (C) 2015-2022 by Frank Reker, Deutsche Telekom AG
+ *
+ * LDT - Lightweight (MP-)DCCP Tunnel kernel module
+ *
+ * This is not Open Source software.
+ * This work is made available to you under a source-available license, as
+ * detailed below.
+ *
+ * Copyright 2022 Deutsche Telekom AG
+ *
+ * Permission is hereby granted, free of charge, subject to below Commons
+ * Clause, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * “Commons Clause” License Condition v1.0
+ *
+ * The Software is provided to you by the Licensor under the License, as
+ * defined below, subject to the following condition.
+ *
+ * Without limiting other conditions in the License, the grant of rights under
+ * the License will not include, and the License does not grant to you, the
+ * right to Sell the Software.
+ *
+ * For purposes of the foregoing, “Sell” means practicing any or all of the
+ * rights granted to you under the License to provide to third parties, for a
+ * fee or other consideration (including without limitation fees for hosting
+ * or consulting/ support services related to the Software), a product or
+ * service whose value derives, entirely or substantially, from the
+ * functionality of the Software. Any license notice or attribution required
+ * by the License must also include this Commons Clause License Condition
+ * notice.
+ *
+ * Licensor: Deutsche Telekom AG
+ */
+
+#include <linux/kernel.h>
+#include <linux/kobject.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#ifdef CONFIG_SYSFS
+#include <linux/sysfs.h>
+#endif
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <net/if_inet6.h>
+#include <linux/in.h>
+#include <linux/in6.h>
+
+#include "ldt_uapi.h"
+#include "ldt_dev.h"
+#include "ldt_tun.h"
+#include "ldt_debug.h"
+#include "ldt_event.h"
+
+#define TUNFUNCHK(tun,f) { if (!(tun)) return -EINVAL; else if (!TUNIFFUNC((tun),f)) return 0; }
+
+static struct ldt_tunops* tp_findtun (const char*);
+static int tptun_rebind (struct ldt_tun*, int);
+
+int
+ldt_tun_init (tun, type)
+	struct ldt_tun	*tun;
+	const char		*type;
+{
+	int	ret;
+	struct timespec64 ts;
+
+	if (!tun || !tun->tdev) return -EINVAL;
+	if (!type) {
+#if IS_ENABLED(CONFIG_IP_MPDCCP)
+		type = "mpdccp4";
+#else
+		type = "dccp4";
+#endif
+	}
+	*tun = (struct ldt_tun) { .tdev = tun->tdev };
+	tp_debug ("create tunnel of type %s\n", type);
+	tun->tunops = tp_findtun (type);
+	if (!tun->tunops) {
+		tp_note ("cannot find tunnel type %s\n", type);
+		return -ENOENT;
+	}
+
+	//tun->ctime = tun->mtime = tun->atime = get_seconds();
+	ktime_get_raw_ts64(&ts);
+	tun->ctime = tun->mtime = tun->atime = ts.tv_sec;
+	ret = tun->tunops->tp_new (tun, type);
+	if (ret < 0) {
+		tp_err ("error setting up tunnel %s: %d", type, ret);
+		ldt_tun_remove (tun);
+		tun->tunops = NULL;
+		return ret;
+	}
+	tp_debug2 ("tunnel creating successfully");
+	return 0;
+}
+
+
+void
+ldt_tun_remove (tun)
+	struct ldt_tun	*tun;
+{
+	if (!tun || !tun->tunops) return;
+	if (tun->tunops && tun->tunops->tp_remove)
+		tun->tunops->tp_remove(tun->tundata);
+	*tun = (struct ldt_tun) { .tdev = tun->tdev,  };
+};
+
+
+
+
+int
+ldt_tun_bind (tun, addr)
+	struct ldt_tun	*tun;
+	tp_addr_t		*addr;
+{
+	int			ret=0;
+	struct timespec64 ts;
+
+	if (!tun || !addr) return -EINVAL;
+	TUNFUNCHK(tun,tp_bind);
+	tp_debug3 ("call tp_bind\n");
+	ret = tun->tunops->tp_bind(tun->tundata, addr, 0);
+	//tun->mtime = get_seconds();
+	ktime_get_raw_ts64(&ts);
+	tun->mtime = ts.tv_sec;
+	if (ret == 0)
+		ldt_event_crsend (LDT_EVTYPE_REBIND, tun, 0);
+	tp_debug3 ("done\n");
+	return ret;
+}
+
+int
+ldt_tun_rebind (tun, flags)
+	struct ldt_tun	*tun;
+	int				flags;
+{
+	int	ret;
+
+	TUNFUNCHK(tun,tp_bind);
+	ret = tptun_rebind (tun,flags);
+	if (ret == 0)
+		ldt_event_crsend (LDT_EVTYPE_REBIND, tun, 0);
+	return ret;
+}
+
+static
+int
+tptun_rebind (tun, flags)
+	struct ldt_tun	*tun;
+	int				flags;
+{
+	struct net_device	*ndev;
+	tp_addr_t			ad;
+	int					ret;
+
+	if (!tun) return -EINVAL;
+	ndev = tun->tdev->pdev;
+	if (!ndev) return -ENOENT;
+	tp_debug3 ("search address\n");
+#if defined (CONFIG_IPV6) && LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0)
+	if (tun->tunops->ipv6) {
+		struct inet6_ifaddr  *ia6;
+		list_for_each_entry(ia6, &(ndev->ip6_ptr->addr_list), if_list) {
+			tp_addr_setipv6 (&ad, ia6->addr.s6_addr, 0);
+			break;
+		}
+	} else
+#endif
+		tp_addr_setipv4 (&ad, ndev->ip_ptr->ifa_list->ifa_local, 0);
+	tp_debug3 ("call tp_bind\n");
+	ret = tun->tunops->tp_bind(tun->tundata, &ad, flags);
+	if (ret < 0) return ret;
+	tp_debug3 ("done\n");
+	return 0;
+}
+
+int
+ldt_tun_peer (tun, addr)
+	struct ldt_tun	*tun;
+	tp_addr_t				*addr;
+{
+	int	ret;
+	struct timespec64 ts;
+
+	TUNFUNCHK(tun,tp_peer);
+	ret = tun->tunops->tp_peer(tun->tundata, addr);
+
+	ktime_get_raw_ts64(&ts);
+	tun->mtime = ts.tv_sec;
+	//tun->mtime = get_seconds();
+	if (ret == 0)
+		ldt_event_crsend (LDT_EVTYPE_REBIND, tun, 0);
+	return ret;
+}
+
+int
+ldt_tun_serverstart (tun)
+	struct ldt_tun	*tun;
+{
+	int	ret;
+
+	TUNFUNCHK(tun,tp_serverstart);
+	ret = tun->tunops->tp_serverstart (tun->tundata);
+	return ret;
+}
+
+int
+ldt_tun_setqueue (tun, txlen, qpolicy)
+	struct ldt_tun	*tun;
+	int						txlen, qpolicy;
+{
+	int	ret;
+
+	TUNFUNCHK(tun,tp_setqueue);
+	ret = tun->tunops->tp_setqueue (tun->tundata, txlen, qpolicy);
+	return ret;
+}
+
+
+int
+ldt_tun_getmtu (tun)
+	struct ldt_tun	*tun;
+{
+	TUNFUNCHK(tun,tp_getmtu);
+	return tun->tunops->tp_getmtu(tun->tundata);
+}
+
+int
+ldt_tun_needheadroom (tun)
+	struct ldt_tun	*tun;
+{
+	TUNFUNCHK(tun,tp_needheadroom);
+	return tun->tunops->tp_needheadroom(tun->tundata);
+}
+
+ssize_t
+ldt_tun_gettuninfo (tun, buf, blen)
+	struct ldt_tun	*tun;
+	char						*buf;
+	size_t					blen;
+{
+	TUNFUNCHK(tun,tp_gettuninfo);
+	return tun->tunops->tp_gettuninfo (tun->tundata, buf, blen);
+}
+
+
+
+int
+ldt_tun_createvent (tun, evbuf, evlen, evtype, desc)
+	struct ldt_tun	*tun;
+	char						*evbuf;
+	size_t					evlen;
+	const char				*evtype;
+	const char				*desc;
+{
+	TUNFUNCHK(tun,tp_createvent);
+	return tun->tunops->tp_createvent(tun->tundata, evbuf, evlen, evtype, desc);
+}
+
+
+int
+ldt_tun_prot1xmit (tun, buf, blen, addr, force)
+	struct ldt_tun *tun;
+	char					*buf;
+	int					blen;
+	tp_addr_t			*addr;
+	int					force;
+{
+	if (!tun || !tun->tunops || !tun->tunops->tp_prot1xmit) return -EINVAL;
+	return tun->tunops->tp_prot1xmit (tun->tundata, buf, blen, addr);
+}
+
+
+
+
+
+
+struct tun_reg {
+	const char					*type;
+	struct ldt_tunops	*tunops;
+	struct tun_reg				*next, *prev;
+};
+static struct tun_reg	*tun_reg_list = NULL;
+
+static DEFINE_MUTEX(tun_mutex);
+static struct tun_reg* tun_reg_find_lock (const char*);
+static struct tun_reg* tun_reg_find (const char*);
+
+int
+ldt_tun_register (type, tunops)
+	const char					*type;
+	struct ldt_tunops	*tunops;
+{
+	struct tun_reg	*p;
+
+	if (!type || !*type || !tunops || !tunops->tp_new) return -EINVAL;
+	mutex_lock (&tun_mutex);
+	p = tun_reg_find (type);
+	if (p) {
+		mutex_unlock (&tun_mutex);
+		return -EEXIST;
+	}
+	p = kmalloc (sizeof (struct tun_reg), GFP_KERNEL);
+	if (!p) {
+		mutex_unlock (&tun_mutex);
+		return -ENOMEM;
+	}
+	*p = (struct tun_reg) { .type = type, .tunops = tunops };
+	p->next = tun_reg_list;
+	if (tun_reg_list) {
+		p->prev = tun_reg_list->prev;
+		tun_reg_list->prev = p;
+	} else {
+		p->prev = p;
+	}
+	tun_reg_list = p;
+	mutex_unlock (&tun_mutex);
+	return 0;
+}
+
+
+void
+ldt_tun_unregister (type)
+	const char					*type;
+{
+	struct tun_reg	*p;
+
+	if (!type || !*type) return;
+	mutex_lock (&tun_mutex);
+	p = tun_reg_find (type);
+	if (!p) {
+		mutex_unlock (&tun_mutex);
+		return;
+	}
+	if (p->next) p->next->prev = p->prev;
+	if (p == tun_reg_list)
+		tun_reg_list = p->next;
+	else
+		p->prev->next = p->next;
+	mutex_unlock (&tun_mutex);
+	*p = (struct tun_reg) { .type = "" };
+	kfree (p);
+}
+
+
+
+static
+struct ldt_tunops*
+tp_findtun (type)
+	const char	*type;
+{
+	struct tun_reg	*p;
+
+	p = tun_reg_find_lock (type);
+	if (!p) return NULL;
+	return p->tunops;
+}
+
+static
+struct tun_reg*
+tun_reg_find_lock (type)
+	const char	*type;
+{
+	struct tun_reg	*p;
+
+	mutex_lock (&tun_mutex);
+	p = tun_reg_find (type);
+	mutex_unlock (&tun_mutex);
+	return p;
+}
+
+static
+struct tun_reg*
+tun_reg_find (type)
+	const char	*type;
+{
+	struct tun_reg	*p;
+
+	if (!type || !*type) return NULL;
+	for (p=tun_reg_list; p; p=p->next)
+		if (!strcasecmp (p->type, type)) return p;
+	return NULL;
+}
+
+
+
+
+
+
+
+/*
+ * Overrides for XEmacs and vim so that we get a uniform tabbing style.
+ * XEmacs/vim will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 3
+ * c-basic-offset: 3
+ * tab-width: 3
+ * End:
+ * vim:tw=0:ts=3:wm=0:
+ */
diff --git a/net/ldt/ldt_tun.h b/net/ldt/ldt_tun.h
new file mode 100644
index 0000000000000..6e2cce4c14bf6
--- /dev/null
+++ b/net/ldt/ldt_tun.h
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2015-2022 by Frank Reker, Deutsche Telekom AG
+ *
+ * LDT - Lightweight (MP-)DCCP Tunnel kernel module
+ *
+ * This is not Open Source software.
+ * This work is made available to you under a source-available license, as
+ * detailed below.
+ *
+ * Copyright 2022 Deutsche Telekom AG
+ *
+ * Permission is hereby granted, free of charge, subject to below Commons
+ * Clause, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * “Commons Clause” License Condition v1.0
+ *
+ * The Software is provided to you by the Licensor under the License, as
+ * defined below, subject to the following condition.
+ *
+ * Without limiting other conditions in the License, the grant of rights under
+ * the License will not include, and the License does not grant to you, the
+ * right to Sell the Software.
+ *
+ * For purposes of the foregoing, “Sell” means practicing any or all of the
+ * rights granted to you under the License to provide to third parties, for a
+ * fee or other consideration (including without limitation fees for hosting
+ * or consulting/ support services related to the Software), a product or
+ * service whose value derives, entirely or substantially, from the
+ * functionality of the Software. Any license notice or attribution required
+ * by the License must also include this Commons Clause License Condition
+ * notice.
+ *
+ * Licensor: Deutsche Telekom AG
+ */
+
+
+#ifndef _R__KERNEL_LDT_TUN_INT_H
+#define _R__KERNEL_LDT_TUN_INT_H
+
+#include <linux/types.h>
+#include <linux/netdevice.h>
+#include "ldt_addr.h"
+#include "ldt_dev.h"
+struct sock;
+
+#define LDT_TUN_BIND_F_ADDRCHG	0x02
+
+struct ldt_tun;
+struct ldt_tunops {
+	int (*tp_new)(struct ldt_tun*, const char *);
+	int (*tp_bind)(void*, tp_addr_t*, int);
+	int (*tp_peer)(void*, tp_addr_t*);
+	int (*tp_serverstart)(void*);
+	void (*tp_remove)(void*);
+	netdev_tx_t (*tp_xmit)(void*,struct sk_buff*);
+	int (*tp_prot1xmit)(void*, char*, int, tp_addr_t*);
+	ssize_t (*tp_gettuninfo)(void*, char*, size_t);
+	int (*tp_createvent)(void*, char*, size_t, const char*, const char*);
+	int (*tp_needheadroom)(void*);
+	int (*tp_getmtu)(void*);
+	int (*tp_setqueue)(void*, int, int);
+	int	ipv6;
+};
+
+
+struct ldt_dev;
+struct ldt_tun {
+	u32							pdevdown:1;
+	void							*tundata;
+	struct ldt_tunops			*tunops;
+	struct ldt_dev				*tdev;
+	//unsigned long						ctime, mtime, atime;
+    time64_t                    ctime, mtime, atime;
+};
+
+#define TUNSTATADD(tun,key,val) \
+	do { (tun)->stats.key += (val); } while (0)
+#define TUNSTATINC(tun,key)	TUNSTATADD(tun,key,1)
+
+int ldt_tun_reginit (void);
+void ldt_tun_regdeinit (void);
+
+int ldt_tun_init (struct ldt_tun*, const char *);
+void ldt_tun_remove (struct ldt_tun *tun);
+int ldt_tun_register (const char *, struct ldt_tunops*);
+void ldt_tun_unregister (const char *);
+
+#define TUN2NET(tun)		((tun)?TDEV2NET((tun)->tdev):(void*)0)
+
+#include <generated/uapi/linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0)
+# define smp_load_acquire(x) *(x)
+# define smp_store_release(x,y) *(x) = (y)
+#endif
+
+#define TUNIFACT(tun)		((tun) && (tun)->tunops)
+#define TUNIFFUNC(tun,f)	(TUNIFACT(tun) && (tun)->tunops->f)
+
+
+/* the xmit we leave here for performance reasons
+ * note that the check for existence and rcu_read_lock is
+ * already performt in ldt_dev - so don't do it again
+ */
+static
+inline
+netdev_tx_t
+ldt_tun_xmit (struct ldt_tun *tun, struct sk_buff *skb)
+{
+	if (!TUNIFACT(tun)) return NETDEV_TX_BUSY;
+	return tun->tunops->tp_xmit (tun->tundata, skb);
+};
+
+
+int ldt_tun_bind (struct ldt_tun*, tp_addr_t *addr);
+int ldt_tun_rebind (struct ldt_tun*, int flags);
+int ldt_tun_peer (struct ldt_tun*, tp_addr_t *addr);
+int ldt_tun_serverstart (struct ldt_tun*);
+int ldt_tun_getmtu (struct ldt_tun *tun);
+int ldt_tun_needheadroom (struct ldt_tun *tun);
+ssize_t ldt_tun_gettuninfo (	struct ldt_tun *tun, char *buf,
+											size_t blen);
+int ldt_tun_createvent (	struct ldt_tun *tun, char *evbuf,
+										size_t evlen, const char *evtype,
+										const char *desc);
+int ldt_tun_prot1xmit (struct ldt_tun *tun, char *buf, int blen,
+									tp_addr_t *addr, int force);
+
+int ldt_tun_setqueue (struct ldt_tun*, int txlen, int qpolicy);
+
+
+
+#endif	/* _R__KERNEL_LDT_TUN_INT_H */
+
+/*
+ * Overrides for XEmacs and vim so that we get a uniform tabbing style.
+ * XEmacs/vim will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 3
+ * c-basic-offset: 3
+ * tab-width: 3
+ * End:
+ * vim:tw=0:ts=3:wm=0:
+ */
diff --git a/net/ldt/ldt_tunaddr.c b/net/ldt/ldt_tunaddr.c
new file mode 100644
index 0000000000000..445a3f836f104
--- /dev/null
+++ b/net/ldt/ldt_tunaddr.c
@@ -0,0 +1,200 @@
+/*
+ * Copyright (C) 2015-2022 by Frank Reker, Deutsche Telekom AG
+ *
+ * LDT - Lightweight (MP-)DCCP Tunnel kernel module
+ *
+ * This is not Open Source software.
+ * This work is made available to you under a source-available license, as
+ * detailed below.
+ *
+ * Copyright 2022 Deutsche Telekom AG
+ *
+ * Permission is hereby granted, free of charge, subject to below Commons
+ * Clause, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * “Commons Clause” License Condition v1.0
+ *
+ * The Software is provided to you by the Licensor under the License, as
+ * defined below, subject to the following condition.
+ *
+ * Without limiting other conditions in the License, the grant of rights under
+ * the License will not include, and the License does not grant to you, the
+ * right to Sell the Software.
+ *
+ * For purposes of the foregoing, “Sell” means practicing any or all of the
+ * rights granted to you under the License to provide to third parties, for a
+ * fee or other consideration (including without limitation fees for hosting
+ * or consulting/ support services related to the Software), a product or
+ * service whose value derives, entirely or substantially, from the
+ * functionality of the Software. Any license notice or attribution required
+ * by the License must also include this Commons Clause License Condition
+ * notice.
+ *
+ * Licensor: Deutsche Telekom AG
+ */
+
+
+#include <linux/kernel.h>
+
+#include "ldt_addr.h"
+#include "ldt_tunaddr.h"
+#include "ldt_dev.h"
+#include "ldt_tun.h"
+
+
+void
+ldt_tunaddr_init (tad, ipv6)
+	tp_tunaddr_t	*tad;
+	int				ipv6;
+{
+	if (!tad) return;
+	*tad = (tp_tunaddr_t) { .ipv6 = ipv6 ? 1 : 0, .anyraddr = 1, };
+	tad->laddr.ad.sa_family = ipv6 ? AF_INET6 : AF_INET;
+	tad->raddr.ad.sa_family = ipv6 ? AF_INET6 : AF_INET;
+}
+
+int
+ldt_tunaddr_bind (tad, addr, flags)
+	tp_tunaddr_t	*tad;
+	tp_addr_t		*addr;
+	int				flags;
+{
+	if (!tad || !addr) return -EINVAL;
+	if (TP_ADDRP_FAM(addr) != TP_ADDR_FAM(tad->raddr)) {
+		tp_debug ("try to bind to wrong address family - expecting %s",
+						tad->ipv6 ? "ipv6" : "ipv4");
+		return -EINVAL;
+	}
+	if (flags & LDT_TUN_BIND_F_ADDRCHG) {
+		if (!tad->bound) return -ENOENT;
+		tp_addr_cpiponly (&tad->laddr, addr);
+		tad->anyladdr = tp_addr_isany (addr);
+	} else {
+		tp_addr_cp (&tad->laddr, addr);
+		tad->anyladdr = tp_addr_isany (addr);
+		tad->lport = tp_addr_getport (addr);
+		tad->anylport = tad->lport == 0;
+	}
+	tad->bound = 1;
+	return 0;
+}
+
+int
+ldt_tunaddr_setpeer (tad, addr, dyn)
+	tp_tunaddr_t	*tad;
+	tp_addr_t		*addr;
+	int				dyn;
+{
+	if (!tad || !addr) return -EINVAL;
+	if (dyn && !tad->anyraddr) return 0;	/* nothing to be done */
+	if (TP_ADDRP_FAM(addr) != TP_ADDR_FAM(tad->raddr)) {
+		tp_debug ("try to connect to wrong address family - expecting %s",
+						tad->ipv6 ? "ipv6" : "ipv4");
+		return -EINVAL;
+	}
+	tp_addr_cp (&tad->raddr, addr);
+	if (!dyn) {
+		tad->anyraddr = tp_addr_isany (addr);
+		tad->hasraddr = !tad->anyraddr;
+	} else {
+		tad->hasraddr = 1;
+	}
+	return 0;
+}
+
+
+int
+ldt_tunaddr_prt (tad, buf, bufsz, spc)
+	tp_tunaddr_t	*tad;
+	char				*buf;
+	int				bufsz;
+	unsigned			spc;
+{
+	int	len=0;
+	char	xbuf[sizeof("xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:255.255.255.255")+2];
+
+	if (!tad) return 0;
+#define MYPRTIP(ad) (tp_addr_sprt_ip (xbuf, sizeof (xbuf), &(ad)) > 0 ? xbuf : "")
+#define _FSTR	(buf ? buf + len : NULL)
+#define _FLEN	(bufsz > len ? bufsz - len : 0)
+	if (TP_ADDR_ISIPV6(tad->laddr))
+		len += snprintf (_FSTR, _FLEN, "%*c<ipv6/>\n", spc, ' ');
+	if (!tad->bound) {
+		len += snprintf (_FSTR, _FLEN, "%*c<locaddr>unbound</locaddr>\n", spc, ' ');
+	} else if (tad->anyladdr) {
+		len += snprintf (_FSTR, _FLEN, "%*c<locaddr>%s</locaddr>\n", spc, ' ',
+												TP_ADDR_ISIPV6(tad->laddr)?"::":"0.0.0.0");
+		len += snprintf (_FSTR, _FLEN, "%*c<actlocaddr>%s</actlocaddr>\n",
+												spc, ' ', MYPRTIP(tad->laddr));
+	} else {
+		len += snprintf (_FSTR, _FLEN, "%*c<locaddr>%s</locaddr>\n", spc, ' ',
+												MYPRTIP(tad->laddr));
+	}
+	if (!tad->bound) {
+		/* nothing */
+	} else if (tad->anylport) {
+		len += snprintf (_FSTR, _FLEN, "%*c<locport>0</locport>\n", spc, ' ');
+		len += snprintf (_FSTR, _FLEN, "%*c<actlocport>%u</actlocport>\n",
+												spc, ' ', tp_addr_getuport (&tad->laddr));
+	} else {
+		len += snprintf (_FSTR, _FLEN, "%*c<locport>%u</locport>\n", spc, ' ',
+												tp_addr_getuport (&tad->laddr));
+	}
+	if (tad->anyraddr) {
+		len += snprintf (_FSTR, _FLEN, "%*c<remaddr>%s</remaddr>\n", spc, ' ',
+												TP_ADDR_ISIPV6(tad->raddr)?"::":"0.0.0.0");
+		len += snprintf (_FSTR, _FLEN, "%*c<remport>0</remport>\n", spc, ' ');
+		if (tad->hasraddr) {
+			len += snprintf (_FSTR, _FLEN, "%*c<actremaddr>%s</actremaddr>\n",
+												spc, ' ', MYPRTIP(tad->raddr));
+			len += snprintf (_FSTR, _FLEN, "%*c<actremport>%u</actremport>\n",
+												spc, ' ', tp_addr_getuport (&tad->raddr));
+		}
+	} else {
+		len += snprintf (_FSTR, _FLEN, "%*c<remaddr>%s</remaddr>\n", spc, ' ',
+												MYPRTIP(tad->raddr));
+		len += snprintf (_FSTR, _FLEN, "%*c<remport>%u</remport>\n", spc, ' ',
+												tp_addr_getuport (&tad->raddr));
+	}
+#undef _FSTR
+#undef _FLEN
+#undef MYPRTIP
+	return len;
+}
+
+
+
+
+
+
+
+
+/*
+ * Overrides for XEmacs and vim so that we get a uniform tabbing style.
+ * XEmacs/vim will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 3
+ * c-basic-offset: 3
+ * tab-width: 3
+ * End:
+ * vim:tw=0:ts=3:wm=0:
+ */
diff --git a/net/ldt/ldt_tunaddr.h b/net/ldt/ldt_tunaddr.h
new file mode 100644
index 0000000000000..7f8d547b0078f
--- /dev/null
+++ b/net/ldt/ldt_tunaddr.h
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2015-2022 by Frank Reker, Deutsche Telekom AG
+ *
+ * LDT - Lightweight (MP-)DCCP Tunnel kernel module
+ *
+ * This is not Open Source software.
+ * This work is made available to you under a source-available license, as
+ * detailed below.
+ *
+ * Copyright 2022 Deutsche Telekom AG
+ *
+ * Permission is hereby granted, free of charge, subject to below Commons
+ * Clause, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * “Commons Clause” License Condition v1.0
+ *
+ * The Software is provided to you by the Licensor under the License, as
+ * defined below, subject to the following condition.
+ *
+ * Without limiting other conditions in the License, the grant of rights under
+ * the License will not include, and the License does not grant to you, the
+ * right to Sell the Software.
+ *
+ * For purposes of the foregoing, “Sell” means practicing any or all of the
+ * rights granted to you under the License to provide to third parties, for a
+ * fee or other consideration (including without limitation fees for hosting
+ * or consulting/ support services related to the Software), a product or
+ * service whose value derives, entirely or substantially, from the
+ * functionality of the Software. Any license notice or attribution required
+ * by the License must also include this Commons Clause License Condition
+ * notice.
+ *
+ * Licensor: Deutsche Telekom AG
+ */
+
+#ifndef _R__KERNEL_LDT_TUNADDR_INT_H
+#define _R__KERNEL_LDT_TUNADDR_INT_H
+
+
+#include "ldt_addr.h"
+
+
+struct ldt_tunaddr {
+	tp_addr_t	laddr,
+					raddr;
+	uint32_t		anyladdr:1,
+					anylport:1,
+					anyraddr:1,
+					hasraddr:1,
+					bound:1,
+					ipv6:1;
+	uint16_t		lport;	/* for route cache speed up */
+};
+
+typedef struct ldt_tunaddr	tp_tunaddr_t;
+
+
+
+void ldt_tunaddr_init (tp_tunaddr_t*, int ipv6);
+int ldt_tunaddr_bind (tp_tunaddr_t*, tp_addr_t*, int flags);
+int ldt_tunaddr_setpeer (tp_tunaddr_t*, tp_addr_t*, int dyn);
+int ldt_tunaddr_prt (tp_tunaddr_t*, char *buf, int bufsz, unsigned spc);
+
+
+
+
+
+
+
+#endif	/* _R__KERNEL_LDT_TUNADDR_INT_H */
+
+
+/*
+ * Overrides for XEmacs and vim so that we get a uniform tabbing style.
+ * XEmacs/vim will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 3
+ * c-basic-offset: 3
+ * tab-width: 3
+ * End:
+ * vim:tw=0:ts=3:wm=0:
+ */
diff --git a/net/ldt/ldt_uapi.h b/net/ldt/ldt_uapi.h
new file mode 100644
index 0000000000000..2ba34d25cc8f3
--- /dev/null
+++ b/net/ldt/ldt_uapi.h
@@ -0,0 +1,302 @@
+/*
+ * Copyright (C) 2015-2022 by Frank Reker, Deutsche Telekom AG
+ *
+ * LDT - Lightweight (MP-)DCCP Tunnel kernel module
+ *
+ * This is not Open Source software.
+ * This work is made available to you under a source-available license, as
+ * detailed below.
+ *
+ * Copyright 2022 Deutsche Telekom AG
+ *
+ * Permission is hereby granted, free of charge, subject to below Commons
+ * Clause, to any person obtaining a copy of this software and associated
+ * documentation files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * “Commons Clause” License Condition v1.0
+ *
+ * The Software is provided to you by the Licensor under the License, as
+ * defined below, subject to the following condition.
+ *
+ * Without limiting other conditions in the License, the grant of rights under
+ * the License will not include, and the License does not grant to you, the
+ * right to Sell the Software.
+ *
+ * For purposes of the foregoing, “Sell” means practicing any or all of the
+ * rights granted to you under the License to provide to third parties, for a
+ * fee or other consideration (including without limitation fees for hosting
+ * or consulting/ support services related to the Software), a product or
+ * service whose value derives, entirely or substantially, from the
+ * functionality of the Software. Any license notice or attribution required
+ * by the License must also include this Commons Clause License Condition
+ * notice.
+ *
+ * Licensor: Deutsche Telekom AG
+ */
+
+
+#ifndef _R__KERNEL_LDT_H
+#define _R__KERNEL_LDT_H
+
+#include <linux/types.h>
+#include <linux/socket.h>
+
+
+/* Note that this file is shared with user space. */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#define LDT_NAME "ldt"
+#define LDT_NL_VERSION 3	/* netlink protocol version */
+
+
+/* netlink definitions */
+
+enum ldt_nl_commands {
+	LDT_CMD_UNSPEC,
+	LDT_CMD_CREATE_DEV,
+	LDT_CMD_RM_DEV,				/* remove device */
+	LDT_CMD_GET_VERSION,
+	LDT_CMD_GET_DEVLIST,
+	LDT_CMD_SHOW_DEV,
+	LDT_CMD_SHOW_DEVLIST,
+	LDT_CMD_RM_TUN,
+	LDT_CMD_NEWTUN,
+	LDT_CMD_BIND,
+	LDT_CMD_BIND2DEV,
+	LDT_CMD_PEER,
+	LDT_CMD_SERVERSTART,
+	LDT_CMD_SET_MTU,
+	LDT_CMD_SET_QUEUE,
+	LDT_CMD_SUBSCRIBE,
+	LDT_CMD_SEND_INFO,			/* answer */
+	LDT_CMD_SEND_EVENT,			/* unsolicate event answer */
+	LDT_CMD_EVSEND,
+	__LDT_CMD_MAX
+};
+#define LDT_CMD_MAX (__LDT_CMD_MAX - 1)
+
+
+
+enum ldt_attrs_create_dev {
+	LDT_CMD_CREATE_DEV_ATTR_UNSPEC,
+	LDT_CMD_CREATE_DEV_ATTR_NAME,	/* NLA_NUL_STRING */
+	LDT_CMD_CREATE_DEV_ATTR_FLAGS,	/* NLA_U32 */
+	__LDT_CMD_CREATE_DEV_ATTR_MAX
+};
+#define LDT_CMD_CREATE_DEV_ATTR_MAX (__LDT_CMD_CREATE_DEV_ATTR_MAX - 1)
+
+#define LDT_CREATE_DEV_F_NONE		0x00
+#define LDT_CREATE_DEV_F_CLIENT		0x01
+#define LDT_CREATE_DEV_F_SERVER		0x02
+
+enum ldt_attrs_rm_dev {
+	LDT_CMD_RM_DEV_ATTR_UNSPEC,
+	LDT_CMD_RM_DEV_ATTR_NAME,	/* NLA_NUL_STRING */
+	__LDT_CMD_RM_DEV_ATTR_MAX
+};
+#define LDT_CMD_RM_DEV_ATTR_MAX (__LDT_CMD_RM_DEV_ATTR_MAX - 1)
+
+
+enum ldt_attrs_get_version {
+	LDT_CMD_GET_VERSION_ATTR_UNSPEC,
+	__LDT_CMD_GET_VERSION_ATTR_MAX
+};
+#define LDT_CMD_GET_VERSION_ATTR_MAX (__LDT_CMD_GET_VERSION_ATTR_MAX - 1)
+
+enum ldt_attrs_get_devlist {
+	LDT_CMD_GET_DEVLIST_ATTR_UNSPEC,
+	__LDT_CMD_GET_DEVLIST_ATTR_MAX
+};
+#define LDT_CMD_GET_DEVLIST_ATTR_MAX (__LDT_CMD_GET_DEVLIST_ATTR_MAX - 1)
+
+enum ldt_attrs_show_dev {
+	LDT_CMD_SHOW_DEV_ATTR_UNSPEC,
+	LDT_CMD_SHOW_DEV_ATTR_NAME,		/* NLA_NUL_STRING */
+	__LDT_CMD_SHOW_DEV_ATTR_MAX
+};
+#define LDT_CMD_SHOW_DEV_ATTR_MAX (__LDT_CMD_SHOW_DEV_ATTR_MAX - 1)
+
+enum ldt_attrs_show_devlist {
+	LDT_CMD_SHOW_DEVLIST_ATTR_UNSPEC,
+	__LDT_CMD_SHOW_DEVLIST_ATTR_MAX
+};
+#define LDT_CMD_SHOW_DEVLIST_ATTR_MAX (__LDT_CMD_SHOW_DEVLIST_ATTR_MAX - 1)
+
+
+enum ldt_attrs_rm_tun {
+	LDT_CMD_RM_TUN_ATTR_UNSPEC,
+	LDT_CMD_RM_TUN_ATTR_NAME,		/* NLA_NUL_STRING */
+	__LDT_CMD_RM_TUN_ATTR_MAX
+};
+#define LDT_CMD_RM_TUN_ATTR_MAX (__LDT_CMD_RM_TUN_ATTR_MAX - 1)
+
+enum ldt_attrs_newtun {
+	LDT_CMD_NEWTUN_ATTR_UNSPEC,
+	LDT_CMD_NEWTUN_ATTR_NAME,			/* NLA_NUL_STRING */
+	LDT_CMD_NEWTUN_ATTR_TUN_TYPE,	/* NLA_NUL_STRING */
+	__LDT_CMD_NEWTUN_ATTR_MAX
+};
+#define LDT_CMD_NEWTUN_ATTR_MAX	(__LDT_CMD_NEWTUN_ATTR_MAX - 1)
+
+enum ldt_attr_bind {
+	LDT_CMD_BIND_ATTR_UNSPEC,
+	LDT_CMD_BIND_ATTR_NAME,		/* NLA_NUL_STRING */
+	LDT_CMD_BIND_ATTR_ADDR4,		/* NLA_U32 */
+	LDT_CMD_BIND_ATTR_ADDR6, 		/* NLA_BINARY */
+	LDT_CMD_BIND_ATTR_PORT,		/* NLA_U16 */
+	__LDT_CMD_BIND_ATTR_MAX
+};
+#define LDT_CMD_BIND_ATTR_MAX	(__LDT_CMD_BIND_ATTR_MAX - 1)
+
+enum ldt_attr_bind2dev {
+	LDT_CMD_BIND2DEV_ATTR_UNSPEC,
+	LDT_CMD_BIND2DEV_ATTR_NAME,		/* NLA_NUL_STRING */
+	LDT_CMD_BIND2DEV_ATTR_DEV, 		/* NLA_NUL_STRING - binding device */
+	__LDT_CMD_BIND2DEV_ATTR_MAX
+};
+#define LDT_CMD_BIND2DEV_ATTR_MAX	(__LDT_CMD_BIND2DEV_ATTR_MAX - 1)
+
+enum ldt_attr_peer {
+	LDT_CMD_PEER_ATTR_UNSPEC,
+	LDT_CMD_PEER_ATTR_NAME,		/* NLA_NUL_STRING */
+	LDT_CMD_PEER_ATTR_ADDR4,		/* NLA_U32 */
+	LDT_CMD_PEER_ATTR_ADDR6, 		/* NLA_BINARY */
+	LDT_CMD_PEER_ATTR_PORT,		/* NLA_U16 */
+	__LDT_CMD_PEER_ATTR_MAX
+};
+#define LDT_CMD_PEER_ATTR_MAX	(__LDT_CMD_PEER_ATTR_MAX - 1)
+
+enum ldt_attr_serverstart {
+	LDT_CMD_SERVERSTART_ATTR_UNSPEC,
+	LDT_CMD_SERVERSTART_ATTR_NAME,		/* NLA_NUL_STRING */
+	__LDT_CMD_SERVERSTART_ATTR_MAX
+};
+#define LDT_CMD_SERVERSTART_ATTR_MAX	(__LDT_CMD_SERVERSTART_ATTR_MAX - 1)
+
+
+enum ldt_attrs_set_mtu {
+	LDT_CMD_SET_MTU_ATTR_UNSPEC,
+	LDT_CMD_SET_MTU_ATTR_NAME,	/* NLA_NUL_STRING */
+	LDT_CMD_SET_MTU_ATTR_MTU,		/* NLA_U32 */
+	__LDT_CMD_SET_MTU_ATTR_MAX
+};
+#define LDT_CMD_SET_MTU_ATTR_MAX (__LDT_CMD_SET_MTU_ATTR_MAX - 1)
+
+
+enum ldt_attrs_setqueue {
+	LDT_CMD_SETQUEUE_ATTR_UNSPEC,
+	LDT_CMD_SETQUEUE_ATTR_NAME,			/* NLA_NUL_STRING */
+	LDT_CMD_SETQUEUE_ATTR_TXQLEN,		/* NLA_U16 */
+	LDT_CMD_SETQUEUE_ATTR_QPOLICY,		/* NLA_U16 */
+	__LDT_CMD_SETQUEUE_ATTR_MAX
+};
+#define LDT_CMD_SETQUEUE_ATTR_MAX (__LDT_CMD_SETQUEUE_ATTR_MAX - 1)
+
+#define LDT_CMD_SETQUEUE_QPOLICY_DROP_NEWEST	0
+#define LDT_CMD_SETQUEUE_QPOLICY_DROP_OLDEST	1
+#define LDT_CMD_SETQUEUE_QPOLICY_MAX				1
+
+
+enum ldt_attrs_send_info {
+	LDT_CMD_SEND_INFO_ATTR_UNSPEC,
+	LDT_CMD_SEND_INFO_ATTR_RET,				/* NLA_BINARY - int */
+	LDT_CMD_SEND_INFO_ATTR_INFO,				/* NLA_BINARY */
+	__LDT_CMD_SEND_INFO_ATTR_MAX,
+};
+#define LDT_CMD_SEND_INFO_ATTR_MAX (__LDT_CMD_SEND_INFO_ATTR_MAX - 1)
+
+enum ldt_attrs_send_event {
+	LDT_CMD_SEND_EVENT_ATTR_UNSPEC,
+	LDT_CMD_SEND_EVENT_ATTR_EVTYPE,			/* NLA_U32 */
+	LDT_CMD_SEND_EVENT_ATTR_IARG,			/* NLA_U32 */
+	LDT_CMD_SEND_EVENT_ATTR_SARG,			/* NLA_NUL_STRING */
+	__LDT_CMD_SEND_EVENT_ATTR_MAX,
+};
+#define LDT_CMD_SEND_EVENT_ATTR_MAX (__LDT_CMD_SEND_EVENT_ATTR_MAX - 1)
+
+enum ldt_attrs_evsend {
+	LDT_CMD_EVSEND_ATTR_UNSPEC,
+	LDT_CMD_EVSEND_ATTR_NAME,		/* NLA_NUL_STRING */
+	LDT_CMD_EVSEND_ATTR_EVTYPE,	/* NLA_U32 */
+	LDT_CMD_EVSEND_ATTR_REASON,	/* NLA_U32 */
+	__LDT_CMD_EVSEND_ATTR_MAX
+};
+#define LDT_CMD_EVSEND_ATTR_MAX (__LDT_CMD_EVSEND_ATTR_MAX - 1)
+
+
+/* event definition */
+
+enum ldt_event_type {
+	LDT_EVTYPE_UNSPEC,
+	LDT_EVTYPE_INIT,						/* initial handshake successfull */
+	LDT_EVTYPE_DOWN,						/* keep alive timed out */
+	LDT_EVTYPE_UP,						/* remote host up again */
+	LDT_EVTYPE_TUNDOWN,					/* tunnel brought down */
+	LDT_EVTYPE_TUNUP,					/* new tunnel brought up */
+	LDT_EVTYPE_IFDOWN,					/* interface brought down */
+	LDT_EVTYPE_IFUP,						/* new interface brought up */
+	LDT_EVTYPE_TPDOWN,					/* ldt module unloaded */
+	LDT_EVTYPE_PDEVDOWN,				/* underlying physical device went down */
+	LDT_EVTYPE_PDEVUP,					/* underlying physical device came up */
+	LDT_EVTYPE_NIFDOWN,					/* some network if went down */
+	LDT_EVTYPE_NIFUP,					/* some network if came up */
+	LDT_EVTYPE_REBIND,					/* tunnel was rebound (tunbind, setpeer) */
+	LDT_EVTYPE_SUBFLOW_UP,				/* new subflow came up */
+	LDT_EVTYPE_SUBFLOW_DOWN,			/* subflow removed */
+	LDT_EVTYPE_CONN_ESTAB,				/* connection established */
+	LDT_EVTYPE_CONN_ESTAB_FAIL,		/* connection establishment failed */
+	LDT_EVTYPE_CONN_ACCEPT,			/* connection accepted */
+	LDT_EVTYPE_CONN_ACCEPT_FAIL,		/* connection failed to accept */
+	LDT_EVTYPE_CONN_LISTEN,			/* server listening */
+	LDT_EVTYPE_CONN_LISTEN_FAIL,		/* listening failed */
+	__LDT_EVTYPE_MAX,
+};
+#define LDT_EVTYPE_MAX (__LDT_EVTYPE_MAX - 1)
+
+
+
+#ifdef __cplusplus
+}	/* extern "C" */
+#endif
+
+
+
+
+
+
+
+#endif /* _R__KERNEL_LDT_H */
+
+
+/*
+ * Overrides for XEmacs and vim so that we get a uniform tabbing style.
+ * XEmacs/vim will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 3
+ * c-basic-offset: 3
+ * tab-width: 3
+ * End:
+ * vim:tw=0:ts=3:wm=0:
+ */
diff --git a/net/ldt/ldt_version.h b/net/ldt/ldt_version.h
new file mode 100644
index 0000000000000..e33cc428ca4b4
--- /dev/null
+++ b/net/ldt/ldt_version.h
@@ -0,0 +1,2 @@
+#define LDT_VERSION	"0.4.1"
+
-- 
2.43.0

